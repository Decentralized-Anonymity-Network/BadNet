Binary files tor-0.4.6.5/.DS_Store and BADNET/.DS_Store differ
diff -urN tor-0.4.6.5/Makefile.in BADNET/Makefile.in
--- tor-0.4.6.5/Makefile.in	2021-06-10 21:49:33
+++ BADNET/Makefile.in	2022-04-23 16:43:11
@@ -4443,7 +4443,7 @@
 	src/feature/relay/relay_handshake.h \
 	src/feature/relay/relay_periodic.h \
 	src/feature/relay/relay_sys.h \
-	src/feature/relay/relay_find_addr.h src/feature/relay/router.h \
+	src/feature/relay/relay_find_addr.h src/feature/relay/router.h src/feature/relay/bkem.h \
 	src/feature/relay/routerkeys.h src/feature/relay/routermode.h \
 	src/feature/relay/selftest.h \
 	src/feature/relay/transport_config.h \
@@ -5494,7 +5494,7 @@
 	src/feature/relay/relay_handshake.h \
 	src/feature/relay/relay_periodic.h \
 	src/feature/relay/relay_sys.h \
-	src/feature/relay/relay_find_addr.h src/feature/relay/router.h \
+	src/feature/relay/relay_find_addr.h src/feature/relay/router.h src/feature/relay/bkem.h \
 	src/feature/relay/routerkeys.h src/feature/relay/routermode.h \
 	src/feature/relay/selftest.h \
 	src/feature/relay/transport_config.h \
diff -urN tor-0.4.6.5/badnet.sh BADNET/badnet.sh
--- tor-0.4.6.5/badnet.sh	1970-01-01 08:00:00
+++ BADNET/badnet.sh	2021-08-10 13:51:13
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+path=`pwd`
+aclocal
+autoconf
+autoheader
+automake
+mkdir -p /usr/local/BADNet-client/lib/keys
+cp -r src/SC/ /usr/local/BADNet-client
+cd ..
+cp BADNet.client /usr/local/BADNet-client
+mkdir -p /usr/local/BADNet-client/log
+cd /usr/local/BADNet-client/log/
+touch notice.log info.log debug.log
+cd /usr/local/BADNet-client/SC
+python3 configure.py client
+cd $path
diff -urN tor-0.4.6.5/configure.ac BADNET/configure.ac
--- tor-0.4.6.5/configure.ac	2021-06-08 01:32:36
+++ BADNET/configure.ac	2022-04-23 13:31:44
@@ -1252,7 +1252,7 @@
 tor_zlib_devpkg_redhat="zlib-devel"
 tor_zlib_devpkg_debian="zlib1g-dev"
 
-TOR_SEARCH_LIBRARY(zlib, $tryzlibdir, [-lz],
+TOR_SEARCH_LIBRARY(zlib, $tryzlibdir, [-lz -lpython3.6 -lgmp -lpbc],
     [#include <zlib.h>],
     [const char * zlibVersion(void);],
     [zlibVersion();], [--with-zlib-dir],
@@ -1266,7 +1266,7 @@
      TOR_ZLIB_LIBS="$TOR_LIBDIR_zlib/libz.a"
    fi
 else
-     TOR_ZLIB_LIBS="-lz"
+     TOR_ZLIB_LIBS="-lz -lpython3.6 -lgmp -lpbc"
 fi
 AC_SUBST(TOR_ZLIB_LIBS)
 
Binary files tor-0.4.6.5/src/.DS_Store and BADNET/src/.DS_Store differ
diff -urN tor-0.4.6.5/src/SC/Client.py BADNET/src/SC/Client.py
--- tor-0.4.6.5/src/SC/Client.py	1970-01-01 08:00:00
+++ BADNET/src/SC/Client.py	2023-01-14 12:02:52
@@ -0,0 +1,27 @@
+from web3 import Web3, HTTPProvider
+
+import contract_abi
+import account
+import binascii
+from Crypto.Cipher import AES
+from ecies import decrypt
+
+web3 = Web3(HTTPProvider("https://sepolia.infura.io/v3/67631e6ab6fc44e49915da74fd957740"))
+contract_instance = web3.eth.contract(address=account.contract_address, abi=contract_abi.abi)
+path = '/usr/local/BADNET-V3-client/'
+
+
+def clientDownloadNSD():
+    filePath = path + "lib/NSD"
+
+    NSDIndex, _NSD = contract_instance.functions.client_download_NSD().call()
+    NSD = binascii.hexlify(_NSD)
+
+    with open(filePath, mode='w') as filename:
+        local = 0
+        for relayID in range(0, len(NSDIndex)):
+            if NSDIndex[relayID]:
+                filename.write(str(relayID+1) + ' ')
+                SRIHash = NSD[local*64:(local+1)*64]
+                filename.write(SRIHash.decode() + '\n')
+                local += 1
diff -urN tor-0.4.6.5/src/SC/Relay.py BADNET/src/SC/Relay.py
--- tor-0.4.6.5/src/SC/Relay.py	1970-01-01 08:00:00
+++ BADNET/src/SC/Relay.py	2023-01-07 22:00:57
@@ -0,0 +1,181 @@
+from web3 import Web3, HTTPProvider
+import contract_abi
+import account
+
+import os
+import time
+import binascii
+import hashlib
+import zlib
+import re
+from Crypto.Cipher import AES
+import secrets
+from ecies import encrypt
+
+web3 = Web3(HTTPProvider("https://sepolia.infura.io/v3/67631e6ab6fc44e49915da74fd957740"))
+contract_instance = web3.eth.contract(address=account.contract_address, abi=contract_abi.abi)
+AES_CBC_IV = b'qqqqqqqqqqqqqqqq'
+path = '/usr/local/BADNET-V3-relay/'
+
+Counter = 1
+relaySet = list()
+
+
+# ============ Registration ============
+
+def relayRegistrationCheck():
+    return contract_instance.functions.relay_registration_check().call({'from': account.wallet_addr})
+
+
+def relayRegister():
+    start = time.time()
+    txn = contract_instance.functions.relay_register().buildTransaction(
+        {
+            'chainId': 11155111,
+            'nonce': web3.eth.getTransactionCount(account.wallet_addr),
+            'gas': 3000000,
+            'value': Web3.toWei(0, 'ether'),
+            'gasPrice': web3.eth.gasPrice,
+        }
+    )
+    signed_txn = web3.eth.account.signTransaction(txn, private_key=account.wallet_private_key)
+    result = web3.eth.sendRawTransaction(signed_txn.rawTransaction)
+    txn_receipt = web3.eth.waitForTransactionReceipt(result, timeout=600)
+    end = time.time()
+    dt = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(start))
+    with open(path + 'log/blockchain.log', mode='a') as filename:
+        filename.write(account.wallet_addr + ',' + str(dt) + ',relay_register,' + str(end-start) + '\n')
+    return txn_receipt
+
+
+# ============ Fetch the set of healthy relays (for encryption/decryption) ============
+
+def relayGetIndexSet():
+    return contract_instance.functions.relay_get_index_set().call({'from': account.wallet_addr})
+
+
+def relayGetCurrentCounter():
+    return contract_instance.functions.relay_get_current_counter().call({'from': account.wallet_addr})
+
+
+def relayGetSet():
+    relayTotalNum, UnhealthySet = relayGetIndexSet()
+    relaySet.clear()
+    for i in range(1, relayTotalNum):
+        relaySet.append(i)
+    for i in UnhealthySet:
+        relaySet.remove(i)
+    global Counter
+    Counter = relayGetCurrentCounter()
+    return Counter, relaySet
+
+
+# ============ SRI Encryption & Upload ============
+
+def padding(text):
+    block_size = 16
+    remainder = len(text.encode('utf-8')) % block_size
+    if remainder:
+        padding_needed = block_size - remainder
+    else:
+        padding_needed = 0
+    text = text + ('\0' * padding_needed)
+    return text.encode('utf-8')
+
+
+def AES_encrypt(plain_text, key):
+    mode = AES.MODE_CBC
+    iv = AES_CBC_IV
+    padded_text = padding(plain_text)
+    cryptos = AES.new(key, mode, iv)
+    cipher_text = cryptos.encrypt(padded_text)
+    return binascii.hexlify(cipher_text)
+
+
+def relayUploadSRIAndNSD(_Counter, Hdr, SRI, Key):
+    _HDR = "0x" + Hdr
+    AES_key = Key[0:32].encode('utf-8')
+    _enSRI = "0x" + AES_encrypt(SRI, AES_key).decode()
+    _NSD = "0x" + hashlib.sha256(SRI.encode()).hexdigest()
+
+    start = time.time()
+    txn = contract_instance.functions.relay_upload_SRI_and_NSD(_Counter, _HDR, _enSRI, _NSD).buildTransaction(
+        {
+            'chainId': 11155111,
+            'nonce': web3.eth.getTransactionCount(account.wallet_addr),
+            'gas': 3000000,
+            'value': Web3.toWei(0, 'ether'),
+            'gasPrice': web3.eth.gasPrice,
+        }
+    )
+    signed_txn = web3.eth.account.signTransaction(txn, private_key=account.wallet_private_key)
+    result = web3.eth.sendRawTransaction(signed_txn.rawTransaction)
+    txn_receipt = ""
+    try:
+        txn_receipt = web3.eth.waitForTransactionReceipt(result, timeout=300)
+    except TimeoutError:
+        with open(path + 'log/blockchain.log', mode='a') as filename:
+            filename.write('Timeout\n')
+    else:
+        end = time.time()
+        dt = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(start))
+        with open(path + 'log/blockchain.log', mode='a') as filename:
+            filename.write(account.wallet_addr + ',' + str(dt) + ',relay_upload_SRI_and_NSD,' + str(end-start) + '\n')
+    return txn_receipt
+
+
+# ============ SRI Download & Decryption  ============
+
+def relayGetCounterList(index):
+    operation, alterSet = contract_instance.functions.relay_get_counter_list(index).call({'from': account.wallet_addr})
+    addSet = []
+    deleteSet = []
+    for i in range(0, len(operation)):
+        if operation[i]:
+            deleteSet += alterSet[i]
+        else:
+            addSet += alterSet[i]
+    return addSet, deleteSet
+
+
+def relayDownloadSRIHelper(index):
+    counter, Hdr, enSRI = contract_instance.functions.relay_download_SRI(index).call({'from': account.wallet_addr})
+    return counter, Hdr.hex(), enSRI.hex()
+
+
+def relayDownloadSRI(relayID):
+    relayCounter, Hdr, relayEnSRI = relayDownloadSRIHelper(relayID)
+    S = relaySet.copy()
+    if relayCounter < Counter:
+        addSet, deleteSet = relayGetCounterList(relayCounter)
+        for i in range(0, len(addSet)):
+            S += addSet[i]
+        for j in range(0, len(deleteSet)):
+            S.remove(deleteSet[j])
+    relayHdr = re.findall(r'.{130}', Hdr)
+    return S, relayHdr, relayEnSRI
+
+
+def AES_decrypt(cipher_text, key):
+    mode = AES.MODE_CBC
+    iv = AES_CBC_IV
+    cryptos = AES.new(key, mode, iv)
+    plain_text = cryptos.decrypt(binascii.a2b_hex(cipher_text))
+    return bytes.decode(plain_text).rstrip('\0')
+
+
+def relayDecryptSRIs(relayID, enSRI, decKey, fileEnd):
+    AES_Key = bytes(decKey[0:32].encode())
+    try:
+        _SRI = AES_decrypt(enSRI, AES_Key)
+    except UnicodeDecodeError:
+        return
+    else:
+        with open(path + 'lib/NIME-cached', mode='a') as filename:
+            filename.write("index " + str(relayID) + '\n')
+            filename.write(_SRI)
+    if fileEnd == 1:
+        if os.path.exists(path + 'lib/NIME'):
+            os.remove(path + 'lib/NIME')
+        if os.path.exists(path + 'lib/NIME-cached'):
+            os.rename(path + 'lib/NIME-cached', path + 'lib/NIME')
diff -urN tor-0.4.6.5/src/SC/configure.py BADNET/src/SC/configure.py
--- tor-0.4.6.5/src/SC/configure.py	1970-01-01 08:00:00
+++ BADNET/src/SC/configure.py	2023-01-14 16:15:22
@@ -0,0 +1,54 @@
+import sys
+import binascii
+from ecies.utils import generate_key
+from eth_account import Account
+
+from web3 import Web3, HTTPProvider
+import contract_abi
+
+
+contract_address = "0xD6bfD430134759a0deebF58da785c116B524A968"
+web3 = Web3(HTTPProvider("https://sepolia.infura.io/v3/67631e6ab6fc44e49915da74fd957740"))
+contract_instance = web3.eth.contract(address=contract_address, abi=contract_abi.abi)
+
+
+def create_account(path):
+    secp_k = generate_key()
+    wallet_private_key = binascii.hexlify(secp_k.secret).decode('utf-8')
+    public_key = secp_k.public_key.format(True)
+    wallet_public_key = binascii.hexlify(public_key).decode('utf-8')
+    account = Account.from_key(wallet_private_key)
+    wallet_addr = account.address
+
+    with open(path, mode='w') as filename:
+        filename.write('contract_address = "' + contract_address + '"' + '\n\n')
+        filename.write('wallet_addr = "' + wallet_addr + '"' + '\n')
+        filename.write('wallet_public_key = "' + wallet_public_key + '"' + '\n')
+        filename.write('wallet_private_key = "' + wallet_private_key + '"' + '\n')
+    print(wallet_addr)
+
+
+def relay_get_upload_period():
+    return contract_instance.functions.relay_get_upload_period().call()
+
+
+def main(argv):
+    if argv[1] == 'client':
+        path = '/usr/local/BADNET-V3-client/SC/account.py'
+        with open(path, mode='w') as filename:
+            filename.write('contract_address = "' + contract_address + '"' + '\n')
+
+    elif argv[1] == 'relay':
+        path = '/usr/local/BADNET-V3-relay/'
+        create_account(path + 'SC/account.py')
+        """
+        RelayUploadPeriod = relay_get_upload_period()
+        with open(path + 'BADNET.relay', mode='a') as filename:
+            filename.write('\n' + 'RelayUploadPeriod ' + str(RelayUploadPeriod))
+        """
+    else:
+        print('Argument error!')
+
+
+if __name__ == '__main__':
+     main(sys.argv)
diff -urN tor-0.4.6.5/src/SC/contract_abi.py BADNET/src/SC/contract_abi.py
--- tor-0.4.6.5/src/SC/contract_abi.py	1970-01-01 08:00:00
+++ BADNET/src/SC/contract_abi.py	2022-11-23 19:21:16
@@ -0,0 +1,314 @@
+abi = [
+	{
+		"inputs": [],
+		"stateMutability": "nonpayable",
+		"type": "constructor"
+	},
+	{
+		"stateMutability": "payable",
+		"type": "fallback"
+	},
+	{
+		"inputs": [],
+		"name": "client_download_NSD",
+		"outputs": [
+			{
+				"internalType": "bool[]",
+				"name": "",
+				"type": "bool[]"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "address payable",
+				"name": "addr",
+				"type": "address"
+			}
+		],
+		"name": "contract_transfer_to_relay",
+		"outputs": [],
+		"stateMutability": "payable",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint16",
+				"name": "i",
+				"type": "uint16"
+			}
+		],
+		"name": "getHealthFlag",
+		"outputs": [
+			{
+				"internalType": "bool",
+				"name": "",
+				"type": "bool"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint16",
+				"name": "i",
+				"type": "uint16"
+			}
+		],
+		"name": "getinfo",
+		"outputs": [
+			{
+				"internalType": "uint8",
+				"name": "",
+				"type": "uint8"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "getrelayIndex",
+		"outputs": [
+			{
+				"internalType": "uint16",
+				"name": "",
+				"type": "uint16"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint16",
+				"name": "size",
+				"type": "uint16"
+			},
+			{
+				"internalType": "uint16[]",
+				"name": "list",
+				"type": "uint16[]"
+			}
+		],
+		"name": "modifyHealthFlag",
+		"outputs": [],
+		"stateMutability": "nonpayable",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_cancellation",
+		"outputs": [],
+		"stateMutability": "nonpayable",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint16",
+				"name": "i",
+				"type": "uint16"
+			}
+		],
+		"name": "relay_download_SRI",
+		"outputs": [
+			{
+				"internalType": "uint8",
+				"name": "",
+				"type": "uint8"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			},
+			{
+				"internalType": "bytes",
+				"name": "",
+				"type": "bytes"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint8",
+				"name": "counter",
+				"type": "uint8"
+			}
+		],
+		"name": "relay_get_counter_list",
+		"outputs": [
+			{
+				"internalType": "bool[]",
+				"name": "",
+				"type": "bool[]"
+			},
+			{
+				"internalType": "uint16[][]",
+				"name": "",
+				"type": "uint16[][]"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_get_current_counter",
+		"outputs": [
+			{
+				"internalType": "uint8",
+				"name": "",
+				"type": "uint8"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_get_index_set",
+		"outputs": [
+			{
+				"internalType": "uint16",
+				"name": "",
+				"type": "uint16"
+			},
+			{
+				"internalType": "uint16[]",
+				"name": "",
+				"type": "uint16[]"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_get_upload_period",
+		"outputs": [
+			{
+				"internalType": "uint256",
+				"name": "",
+				"type": "uint256"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_register",
+		"outputs": [],
+		"stateMutability": "nonpayable",
+		"type": "function"
+	},
+	{
+		"inputs": [],
+		"name": "relay_registration_check",
+		"outputs": [
+			{
+				"internalType": "uint16",
+				"name": "",
+				"type": "uint16"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint8",
+				"name": "_counter",
+				"type": "uint8"
+			},
+			{
+				"internalType": "bytes",
+				"name": "_Hdr",
+				"type": "bytes"
+			},
+			{
+				"internalType": "bytes",
+				"name": "_encryptedSRI",
+				"type": "bytes"
+			},
+			{
+				"internalType": "bytes",
+				"name": "_NSD",
+				"type": "bytes"
+			}
+		],
+		"name": "relay_upload_SRI_and_NSD",
+		"outputs": [],
+		"stateMutability": "nonpayable",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint256",
+				"name": "period",
+				"type": "uint256"
+			}
+		],
+		"name": "setSRIperiod",
+		"outputs": [],
+		"stateMutability": "nonpayable",
+		"type": "function"
+	},
+	{
+		"inputs": [
+			{
+				"internalType": "uint256",
+				"name": "",
+				"type": "uint256"
+			}
+		],
+		"name": "unhealthyRelaySet",
+		"outputs": [
+			{
+				"internalType": "uint16",
+				"name": "",
+				"type": "uint16"
+			}
+		],
+		"stateMutability": "view",
+		"type": "function"
+	},
+	{
+		"stateMutability": "payable",
+		"type": "receive"
+	}
+]
diff -urN tor-0.4.6.5/src/core/mainloop/mainloop.c BADNET/src/core/mainloop/mainloop.c
--- tor-0.4.6.5/src/core/mainloop/mainloop.c	2021-04-16 00:41:14
+++ BADNET/src/core/mainloop/mainloop.c	2023-01-14 15:22:37
@@ -1720,11 +1720,18 @@
    *    and we make a new circ if there are no clean circuits.
    */
   const int have_dir_info = router_have_minimum_dir_info();
+
+  // ************
+  // BADNET
+  // ************
+  /*  
   if (have_dir_info && !net_is_disabled()) {
     circuit_build_needed_circs(now);
   } else {
     circuit_expire_old_circs_as_needed(now);
   }
+  */
+  circuit_build_needed_circs(now);
 
   /* 5. We do housekeeping for each connection... */
   channel_update_bad_for_new_circs(NULL, 0);
@@ -2059,6 +2066,11 @@
   return ROUTERLIST_PRUNING_INTERVAL;
 }
 
+// ************
+// BADNET
+// ************
+static int NSD_download_times = 60;
+
 /**
  * Periodic event: once a minute, (or every second if TestingTorNetwork, or
  * during client bootstrap), check whether we want to download any
@@ -2075,6 +2087,11 @@
   int networkstatus_dl_check_interval = 60;
   /* check more often when testing, or when bootstrapping from mirrors
    * (connection limits prevent too many connections being made) */
+
+  // ************
+  // BADNET
+  // ************
+  /*
   if (options->TestingTorNetwork
       || (we_are_bootstrapping && prefer_mirrors)) {
     networkstatus_dl_check_interval = 1;
@@ -2084,6 +2101,22 @@
     return PERIODIC_EVENT_NO_UPDATE;
 
   update_networkstatus_downloads(now);
+  */
+  const int is_server = server_mode(options);
+  const int is_client = options_any_client_port_set(options) || !is_server;
+
+  if (is_client){
+    if (NSD_download_times == 60) {
+      if(download_NSD_from_blockchain()) {
+        log_info(LD_DIR, "Periodic callback: client downloads NSD.");
+        NSD_download_times = 0;
+        router_reload_consensus_networkstatus();
+      }
+    } else {
+      NSD_download_times++;
+    }
+  }
+
   return networkstatus_dl_check_interval;
 }
 
diff -urN tor-0.4.6.5/src/core/or/connection_or.c BADNET/src/core/or/connection_or.c
--- tor-0.4.6.5/src/core/or/connection_or.c	2021-04-16 00:41:14
+++ BADNET/src/core/or/connection_or.c	2021-08-10 20:44:54
@@ -813,6 +813,11 @@
 int
 connection_or_digest_is_known_relay(const char *id_digest)
 {
+  // ************
+  // BADNet
+  // ************
+  return 1;
+
   if (router_get_consensus_status_by_id(id_digest))
     return 1; /* It's in the consensus: "yes" */
   if (router_get_by_id_digest(id_digest))
Binary files tor-0.4.6.5/src/feature/.DS_Store and BADNET/src/feature/.DS_Store differ
diff -urN tor-0.4.6.5/src/feature/client/entrynodes.c BADNET/src/feature/client/entrynodes.c
--- tor-0.4.6.5/src/feature/client/entrynodes.c	2021-04-16 00:41:14
+++ BADNET/src/feature/client/entrynodes.c	2023-01-14 12:43:47
@@ -1163,11 +1163,16 @@
   tor_assert(gs);
   const or_options_t *options = get_options();
 
+  // ************
+  // BADNET
+  // ************
+  /*
   if (reasonably_live_consensus_is_missing(gs)) {
     log_info(LD_GUARD, "Not expanding the sample guard set; we have "
              "no reasonably live consensus.");
     return NULL;
   }
+  */
 
   int n_sampled = smartlist_len(gs->sampled_entry_guards);
   entry_guard_t *added_guard = NULL;
diff -urN tor-0.4.6.5/src/feature/dirclient/dirclient.c BADNET/src/feature/dirclient/dirclient.c
--- tor-0.4.6.5/src/feature/dirclient/dirclient.c	2021-06-02 00:16:24
+++ BADNET/src/feature/dirclient/dirclient.c	2021-08-10 20:24:23
@@ -1873,8 +1873,14 @@
   /* If we're pretty sure that we have a compressed directory, and
    * we didn't manage to uncompress it, then warn and bail. */
   if (!plausible && !new_body) {
-    const int LOG_INTERVAL = 3600;
-    static ratelim_t warning_limit = RATELIM_INIT(LOG_INTERVAL);
+
+    // ************
+    // BADNet (Tor-0.4.6.5 bug)
+    // ************
+    // const int LOG_INTERVAL = 3600;
+    // static ratelim_t warning_limit = RATELIM_INIT(LOG_INTERVAL);
+    static ratelim_t warning_limit = RATELIM_INIT(60 * 60);
+    
     log_fn_ratelim(&warning_limit, LOG_WARN, LD_HTTP,
            "Unable to decompress HTTP body (tried %s%s%s, on %s).",
            description1,
diff -urN tor-0.4.6.5/src/feature/dirparse/ns_parse.c BADNET/src/feature/dirparse/ns_parse.c
--- tor-0.4.6.5/src/feature/dirparse/ns_parse.c	2021-04-16 00:41:14
+++ BADNET/src/feature/dirparse/ns_parse.c	2023-01-14 12:32:42
@@ -42,10 +42,20 @@
 #undef log
 #include <math.h>
 
+// ************
+// BADNET
+// ************
+#include "lib/crypt_ops/crypto_curve25519.h"
+#include "lib/crypt_ops/crypto_ed25519.h"
+
 /** List of tokens recognized in the body part of v3 networkstatus
  * documents. */
 // clang-format off
 static token_rule_t rtrstatus_token_table[] = {
+  // ************
+  // BADNET
+  // ************
+  /*
   T01("p",                   K_P,               CONCAT_ARGS, NO_OBJ ),
   T1( "r",                   K_R,                   GE(7),   NO_OBJ ),
   T0N("a",                   K_A,                   GE(1),   NO_OBJ ),
@@ -56,6 +66,11 @@
   T0N("id",                  K_ID,                  GE(2),   NO_OBJ ),
   T1("pr",                   K_PROTO,           CONCAT_ARGS, NO_OBJ ),
   T0N("opt",                 K_OPT,             CONCAT_ARGS, OBJ_OK ),
+  */
+  T1( "r",                  K_R,                GE(4),       NO_OBJ ),
+  T1( "onion-key",          K_ONION_KEY,        NO_ARGS,     NEED_KEY_1024 ),
+  T01("ntor-onion-key",     K_ONION_KEY_NTOR,   GE(1),       NO_OBJ ),
+  T0N("id",                 K_ID,               GE(2),       NO_OBJ ),
   END_OF_TABLE
 };
 // clang-format on
@@ -332,8 +347,13 @@
     log_warn(LD_DIR, "Impossibly short router status");
     goto err;
   }
+
+  // ************
+  // BADNET
+  // ************
   tok = find_by_keyword(tokens, K_R);
-  tor_assert(tok->n_args >= 7); /* guaranteed by GE(7) in K_R setup */
+  // tor_assert(tok->n_args >= 7); /* guaranteed by GE(7) in K_R setup */
+  tor_assert(tok->n_args >= 4); /* guaranteed by GE(4) in K_R setup */
   if (flav == FLAV_NS) {
     if (tok->n_args < 8) {
       log_warn(LD_DIR, "Too few arguments to r");
@@ -363,215 +383,91 @@
     goto err;
   }
 
-  if (flav == FLAV_NS) {
-    if (digest_from_base64(rs->descriptor_digest, tok->args[2])) {
-      log_warn(LD_DIR, "Error decoding descriptor digest %s",
-               escaped(tok->args[2]));
-      goto err;
-    }
-  }
-
-  if (tor_snprintf(timebuf, sizeof(timebuf), "%s %s",
-                   tok->args[3+offset], tok->args[4+offset]) < 0 ||
-      parse_iso_time(timebuf, &rs->published_on)<0) {
-    log_warn(LD_DIR, "Error parsing time '%s %s' [%d %d]",
-             tok->args[3+offset], tok->args[4+offset],
-             offset, (int)flav);
-    goto err;
-  }
-
-  if (tor_inet_aton(tok->args[5+offset], &in) == 0) {
+  if (tor_inet_aton(tok->args[3+offset], &in) == 0) {
     log_warn(LD_DIR, "Error parsing router address in network-status %s",
-             escaped(tok->args[5+offset]));
+             escaped(tok->args[3+offset]));
     goto err;
   }
   tor_addr_from_in(&rs->ipv4_addr, &in);
-
-  rs->ipv4_orport = (uint16_t) tor_parse_long(tok->args[6+offset],
+  rs->ipv4_orport = (uint16_t) tor_parse_long(tok->args[4+offset],
                                               10,0,65535,NULL,NULL);
-  rs->ipv4_dirport = (uint16_t) tor_parse_long(tok->args[7+offset],
-                                               10,0,65535,NULL,NULL);
 
-  {
-    smartlist_t *a_lines = find_all_by_keyword(tokens, K_A);
-    if (a_lines) {
-      find_single_ipv6_orport(a_lines, &rs->ipv6_addr, &rs->ipv6_orport);
-      smartlist_free(a_lines);
-    }
+  rs->md = tor_malloc_zero(sizeof(microdesc_t));
+  tok = find_by_keyword(tokens, K_ONION_KEY);
+  if (!crypto_pk_public_exponent_ok(tok->key)) {
+    log_warn(LD_DIR,
+             "Relay's onion key had invalid exponent.");
+    goto err;
   }
+  rs->md->onion_pkey = tor_memdup(tok->object_body, tok->object_size);
+  rs->md->onion_pkey_len = tok->object_size;
+  crypto_pk_free(tok->key);
 
-  tok = find_opt_by_keyword(tokens, K_S);
-  if (tok && vote) {
-    int i;
-    vote_rs->flags = 0;
-    for (i=0; i < tok->n_args; ++i) {
-      int p = smartlist_string_pos(vote->known_flags, tok->args[i]);
-      if (p >= 0) {
-        vote_rs->flags |= (UINT64_C(1)<<p);
-      } else {
-        log_warn(LD_DIR, "Flags line had a flag %s not listed in known_flags.",
-                 escaped(tok->args[i]));
-        goto err;
-      }
-    }
-  } else if (tok) {
-    /* This is a consensus, not a vote. */
-    int i;
-    for (i=0; i < tok->n_args; ++i) {
-      if (!strcmp(tok->args[i], "Exit"))
-        rs->is_exit = 1;
-      else if (!strcmp(tok->args[i], "Stable"))
-        rs->is_stable = 1;
-      else if (!strcmp(tok->args[i], "Fast"))
-        rs->is_fast = 1;
-      else if (!strcmp(tok->args[i], "Running"))
-        rs->is_flagged_running = 1;
-      else if (!strcmp(tok->args[i], "Named"))
-        rs->is_named = 1;
-      else if (!strcmp(tok->args[i], "Valid"))
-        rs->is_valid = 1;
-      else if (!strcmp(tok->args[i], "Guard"))
-        rs->is_possible_guard = 1;
-      else if (!strcmp(tok->args[i], "BadExit"))
-        rs->is_bad_exit = 1;
-      else if (!strcmp(tok->args[i], "Authority"))
-        rs->is_authority = 1;
-      else if (!strcmp(tok->args[i], "Unnamed") &&
-               consensus_method >= 2) {
-        /* Unnamed is computed right by consensus method 2 and later. */
-        rs->is_unnamed = 1;
-      } else if (!strcmp(tok->args[i], "HSDir")) {
-        rs->is_hs_dir = 1;
-      } else if (!strcmp(tok->args[i], "V2Dir")) {
-        rs->is_v2_dir = 1;
-      } else if (!strcmp(tok->args[i], "StaleDesc")) {
-        rs->is_staledesc = 1;
-      } else if (!strcmp(tok->args[i], "Sybil")) {
-        rs->is_sybil = 1;
-      }
-    }
-    /* These are implied true by having been included in a consensus made
-     * with a given method */
-    rs->is_flagged_running = 1; /* Starting with consensus method 4. */
-    rs->is_valid = 1; /* Starting with consensus method 24. */
-  }
-  {
-    const char *protocols = NULL, *version = NULL;
-    if ((tok = find_opt_by_keyword(tokens, K_PROTO))) {
-      tor_assert(tok->n_args == 1);
-      protocols = tok->args[0];
-    }
-    if ((tok = find_opt_by_keyword(tokens, K_V))) {
-      tor_assert(tok->n_args == 1);
-      version = tok->args[0];
-      if (vote_rs) {
-        vote_rs->version = tor_strdup(tok->args[0]);
-      }
-    }
-
-    // If the protover line is malformed, reject this routerstatus.
-    if (protocols && protover_list_is_invalid(protocols)) {
+  if ((tok = find_opt_by_keyword(tokens, K_ONION_KEY_NTOR))) {
+    curve25519_public_key_t k;
+    tor_assert(tok->n_args >= 1);
+    if (curve25519_public_from_base64(&k, tok->args[0]) < 0) {
+      log_warn(LD_DIR, "Bogus ntor-onion-key in microdesc");
       goto err;
     }
-    summarize_protover_flags(&rs->pv, protocols, version);
+    rs->md->onion_curve25519_pkey =
+      tor_memdup(&k, sizeof(curve25519_public_key_t));
   }
 
-  /* handle weighting/bandwidth info */
-  if ((tok = find_opt_by_keyword(tokens, K_W))) {
-    int i;
-    for (i=0; i < tok->n_args; ++i) {
-      if (!strcmpstart(tok->args[i], "Bandwidth=")) {
-        int ok;
-        rs->bandwidth_kb =
-          (uint32_t)tor_parse_ulong(strchr(tok->args[i], '=')+1,
-                                    10, 0, UINT32_MAX,
-                                    &ok, NULL);
-        if (!ok) {
-          log_warn(LD_DIR, "Invalid Bandwidth %s", escaped(tok->args[i]));
+  smartlist_t *id_lines = find_all_by_keyword(tokens, K_ID);
+  if (id_lines) {
+    SMARTLIST_FOREACH_BEGIN(id_lines, directory_token_t *, t) {
+      tor_assert(t->n_args >= 2);
+      if (!strcmp(t->args[0], "ed25519")) {
+        if (rs->md->ed25519_identity_pkey) {
+          log_warn(LD_DIR, "Extra ed25519 key in microdesc");
+          smartlist_free(id_lines);
           goto err;
         }
-        rs->has_bandwidth = 1;
-      } else if (!strcmpstart(tok->args[i], "Measured=") && vote_rs) {
-        int ok;
-        vote_rs->measured_bw_kb =
-            (uint32_t)tor_parse_ulong(strchr(tok->args[i], '=')+1,
-                                      10, 0, UINT32_MAX, &ok, NULL);
-        if (!ok) {
-          log_warn(LD_DIR, "Invalid Measured Bandwidth %s",
-                   escaped(tok->args[i]));
+        ed25519_public_key_t k;
+        if (ed25519_public_from_base64(&k, t->args[1])<0) {
+          log_warn(LD_DIR, "Bogus ed25519 key in microdesc");
+          smartlist_free(id_lines);
           goto err;
         }
-        vote_rs->has_measured_bw = 1;
-        vote->has_measured_bws = 1;
-      } else if (!strcmpstart(tok->args[i], "Unmeasured=1")) {
-        rs->bw_is_unmeasured = 1;
-      } else if (!strcmpstart(tok->args[i], "GuardFraction=")) {
-        if (routerstatus_parse_guardfraction(tok->args[i],
-                                             vote, vote_rs, rs) < 0) {
-          goto err;
-        }
+        rs->md->ed25519_identity_pkey = tor_memdup(&k, sizeof(k));
       }
-    }
+    } SMARTLIST_FOREACH_END(t);
+    smartlist_free(id_lines);
   }
 
-  /* parse exit policy summaries */
-  if ((tok = find_opt_by_keyword(tokens, K_P))) {
-    tor_assert(tok->n_args == 1);
-    if (strcmpstart(tok->args[0], "accept ") &&
-        strcmpstart(tok->args[0], "reject ")) {
-      log_warn(LD_DIR, "Unknown exit policy summary type %s.",
-               escaped(tok->args[0]));
-      goto err;
-    }
-    /* XXX weasel: parse this into ports and represent them somehow smart,
-     * maybe not here but somewhere on if we need it for the client.
-     * we should still parse it here to check it's valid tho.
-     */
-    rs->exitsummary = tor_strdup(tok->args[0]);
-    rs->has_exitsummary = 1;
+  rs->md->exit_policy = parse_short_policy("accept 1-65535");
+
+  /* This is a consensus, not a vote. */
+  rs->is_exit = 1;
+  rs->is_stable = 1;
+  rs->is_fast = 1;
+  rs->is_flagged_running = 1;
+  rs->is_valid = 1;
+  rs->is_possible_guard = 1;
+  rs->is_hs_dir = 1;
+  rs->is_v2_dir = 1;
+
+  {
+    const char *protocols = NULL, *version = NULL;
+    protocols = "Cons=1-2 Desc=1-2 DirCache=1-2 HSDir=1-2 HSIntro=3-5 HSRend=1-2 Link=1-5 LinkAuth=1,3 Microdesc=1-2 Relay=1-2 Padding=2 FlowCtrl=1";
+    version = "Tor 0.4.6.5";
+    summarize_protover_flags(&rs->pv, protocols, version);
   }
 
-  if (vote_rs) {
-    SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, t) {
-      if (t->tp == K_M && t->n_args) {
-        vote_microdesc_hash_t *line =
-          tor_malloc(sizeof(vote_microdesc_hash_t));
-        line->next = vote_rs->microdesc;
-        line->microdesc_hash_line = tor_strdup(t->args[0]);
-        vote_rs->microdesc = line;
-      }
-      if (t->tp == K_ID) {
-        tor_assert(t->n_args >= 2);
-        if (!strcmp(t->args[0], "ed25519")) {
-          vote_rs->has_ed25519_listing = 1;
-          if (strcmp(t->args[1], "none") &&
-              digest256_from_base64((char*)vote_rs->ed25519_id,
-                                    t->args[1])<0) {
-            log_warn(LD_DIR, "Bogus ed25519 key in networkstatus vote");
-            goto err;
-          }
-        }
-      }
-      if (t->tp == K_PROTO) {
-        tor_assert(t->n_args == 1);
-        vote_rs->protocols = tor_strdup(t->args[0]);
-      }
-    } SMARTLIST_FOREACH_END(t);
-  } else if (flav == FLAV_MICRODESC) {
-    tok = find_opt_by_keyword(tokens, K_M);
-    if (tok) {
-      tor_assert(tok->n_args);
-      if (digest256_from_base64(rs->descriptor_digest, tok->args[0])) {
-        log_warn(LD_DIR, "Error decoding microdescriptor digest %s",
-                 escaped(tok->args[0]));
-        goto err;
-      }
-    } else {
-      log_info(LD_BUG, "Found an entry in networkstatus with no "
-               "microdescriptor digest. (Router %s ($%s) at %s:%d.)",
-               rs->nickname, hex_str(rs->identity_digest, DIGEST_LEN),
-               fmt_addr(&rs->ipv4_addr), rs->ipv4_orport);
+  /* handle weighting/bandwidth info */
+  {
+    int ok;
+    rs->bandwidth_kb =
+      (uint32_t)tor_parse_ulong(strchr("Bandwidth=1", '=')+1,
+                                10, 0, UINT32_MAX,
+                                &ok, NULL);
+    if (!ok) {
+      log_warn(LD_DIR, "Invalid Bandwidth %s", escaped("Bandwidth=1"));
+      goto err;
     }
+    rs->has_bandwidth = 1;
+    rs->bw_is_unmeasured = 1;
   }
 
   if (!strcasecmp(rs->nickname, UNNAMED_ROUTER_NICKNAME))
@@ -1111,182 +1007,38 @@
   if (eos_out)
     *eos_out = NULL;
 
-  if (router_get_networkstatus_v3_hashes(s, s_len, &ns_digests) ||
-      router_get_networkstatus_v3_sha3_as_signed(sha3_as_signed,
-                                                 s, s_len)<0) {
-    log_warn(LD_DIR, "Unable to compute digest of network-status");
-    goto err;
-  }
-
-  area = memarea_new();
-  end_of_header = find_start_of_next_routerstatus(s, eos);
-  if (tokenize_string(area, s, end_of_header, tokens,
-                      (ns_type == NS_TYPE_CONSENSUS) ?
-                      networkstatus_consensus_token_table :
-                      networkstatus_token_table, 0)) {
-    log_warn(LD_DIR, "Error tokenizing network-status header");
-    goto err;
-  }
-
+  // ************
+  // BADNET
+  // ************
   ns = tor_malloc_zero(sizeof(networkstatus_t));
-  memcpy(&ns->digests, &ns_digests, sizeof(ns_digests));
-  memcpy(&ns->digest_sha3_as_signed, sha3_as_signed, sizeof(sha3_as_signed));
 
-  tok = find_by_keyword(tokens, K_NETWORK_STATUS_VERSION);
-  tor_assert(tok);
-  if (tok->n_args > 1) {
-    int flavor = networkstatus_parse_flavor_name(tok->args[1]);
-    if (flavor < 0) {
-      log_warn(LD_DIR, "Can't parse document with unknown flavor %s",
-               escaped(tok->args[1]));
-      goto err;
-    }
-    ns->flavor = flav = flavor;
-  }
-  if (flav != FLAV_NS && ns_type != NS_TYPE_CONSENSUS) {
-    log_warn(LD_DIR, "Flavor found on non-consensus networkstatus.");
+  int flavor = networkstatus_parse_flavor_name("microdesc");
+  if (flavor < 0) {
+    log_warn(LD_DIR, "Can't parse document with unknown flavor");
     goto err;
   }
+  ns->flavor = flav = flavor;
 
-  if (ns_type != NS_TYPE_CONSENSUS) {
-    const char *end_of_cert = NULL;
-    if (!(cert = tor_memstr(s, end_of_header - s,
-                            "\ndir-key-certificate-version")))
-      goto err;
-    ++cert;
-    ns->cert = authority_cert_parse_from_string(cert, end_of_header - cert,
-                                                &end_of_cert);
-    if (!ns->cert || !end_of_cert || end_of_cert > end_of_header)
-      goto err;
-  }
-
-  tok = find_by_keyword(tokens, K_VOTE_STATUS);
-  tor_assert(tok->n_args);
-  if (!strcmp(tok->args[0], "vote")) {
-    ns->type = NS_TYPE_VOTE;
-  } else if (!strcmp(tok->args[0], "consensus")) {
-    ns->type = NS_TYPE_CONSENSUS;
-  } else if (!strcmp(tok->args[0], "opinion")) {
-    ns->type = NS_TYPE_OPINION;
-  } else {
-    log_warn(LD_DIR, "Unrecognized vote status %s in network-status",
-             escaped(tok->args[0]));
-    goto err;
-  }
+  ns->type = NS_TYPE_CONSENSUS;
   if (ns_type != ns->type) {
     log_warn(LD_DIR, "Got the wrong kind of v3 networkstatus.");
     goto err;
   }
 
-  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_OPINION) {
-    tok = find_by_keyword(tokens, K_PUBLISHED);
-    if (parse_iso_time(tok->args[0], &ns->published))
-      goto err;
+  ns->consensus_method = 29;
 
-    ns->supported_methods = smartlist_new();
-    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHODS);
-    if (tok) {
-      for (i=0; i < tok->n_args; ++i)
-        smartlist_add_strdup(ns->supported_methods, tok->args[i]);
-    } else {
-      smartlist_add_strdup(ns->supported_methods, "1");
-    }
-  } else {
-    tok = find_opt_by_keyword(tokens, K_CONSENSUS_METHOD);
-    if (tok) {
-      int num_ok;
-      ns->consensus_method = (int)tor_parse_long(tok->args[0], 10, 1, INT_MAX,
-                                                 &num_ok, NULL);
-      if (!num_ok)
-        goto err;
-    } else {
-      ns->consensus_method = 1;
-    }
-  }
+  ns->recommended_client_protocols = tor_strdup("Cons=1-2 Desc=1-2 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=4 Microdesc=1-2 Relay=2");
+  ns->recommended_relay_protocols = tor_strdup("Cons=1-2 Desc=1-2 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=4 Microdesc=1-2 Relay=2");
+  ns->required_client_protocols = tor_strdup("Cons=1-2 Desc=1-2 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=4 Microdesc=1-2 Relay=2");
+  ns->required_relay_protocols = tor_strdup("Cons=1 Desc=1 DirCache=1 HSDir=1 HSIntro=3 HSRend=1 Link=3-4 Microdesc=1 Relay=1-2");
 
-  // Reject the vote if any of the protocols lines are malformed.
-  bool unparseable = false;
-  ns->recommended_client_protocols = dup_protocols_string(tokens, &unparseable,
-                                         K_RECOMMENDED_CLIENT_PROTOCOLS);
-  ns->recommended_relay_protocols = dup_protocols_string(tokens, &unparseable,
-                                         K_RECOMMENDED_RELAY_PROTOCOLS);
-  ns->required_client_protocols = dup_protocols_string(tokens, &unparseable,
-                                         K_REQUIRED_CLIENT_PROTOCOLS);
-  ns->required_relay_protocols = dup_protocols_string(tokens, &unparseable,
-                                         K_REQUIRED_RELAY_PROTOCOLS);
-  if (unparseable)
-    goto err;
-
-  tok = find_by_keyword(tokens, K_VALID_AFTER);
-  if (parse_iso_time(tok->args[0], &ns->valid_after))
-    goto err;
-
-  tok = find_by_keyword(tokens, K_FRESH_UNTIL);
-  if (parse_iso_time(tok->args[0], &ns->fresh_until))
-    goto err;
-
-  tok = find_by_keyword(tokens, K_VALID_UNTIL);
-  if (parse_iso_time(tok->args[0], &ns->valid_until))
-    goto err;
-
-  tok = find_by_keyword(tokens, K_VOTING_DELAY);
-  tor_assert(tok->n_args >= 2);
-  {
-    int ok;
-    ns->vote_seconds =
-      (int) tor_parse_long(tok->args[0], 10, 0, INT_MAX, &ok, NULL);
-    if (!ok)
-      goto err;
-    ns->dist_seconds =
-      (int) tor_parse_long(tok->args[1], 10, 0, INT_MAX, &ok, NULL);
-    if (!ok)
-      goto err;
-  }
-  if (ns->valid_after +
-      (get_options()->TestingTorNetwork ?
-       MIN_VOTE_INTERVAL_TESTING : MIN_VOTE_INTERVAL) > ns->fresh_until) {
-    log_warn(LD_DIR, "Vote/consensus freshness interval is too short");
-    goto err;
-  }
-  if (ns->valid_after +
-      (get_options()->TestingTorNetwork ?
-       MIN_VOTE_INTERVAL_TESTING : MIN_VOTE_INTERVAL)*2 > ns->valid_until) {
-    log_warn(LD_DIR, "Vote/consensus liveness interval is too short");
-    goto err;
-  }
-  if (ns->vote_seconds < MIN_VOTE_SECONDS) {
-    log_warn(LD_DIR, "Vote seconds is too short");
-    goto err;
-  }
-  if (ns->dist_seconds < MIN_DIST_SECONDS) {
-    log_warn(LD_DIR, "Dist seconds is too short");
-    goto err;
-  }
-
-  if ((tok = find_opt_by_keyword(tokens, K_CLIENT_VERSIONS))) {
-    ns->client_versions = tor_strdup(tok->args[0]);
-  }
-  if ((tok = find_opt_by_keyword(tokens, K_SERVER_VERSIONS))) {
-    ns->server_versions = tor_strdup(tok->args[0]);
-  }
-
-  {
-    smartlist_t *package_lst = find_all_by_keyword(tokens, K_PACKAGE);
-    ns->package_lines = smartlist_new();
-    if (package_lst) {
-      SMARTLIST_FOREACH(package_lst, directory_token_t *, t,
-                    smartlist_add_strdup(ns->package_lines, t->args[0]));
-    }
-    smartlist_free(package_lst);
-  }
-
-  tok = find_by_keyword(tokens, K_KNOWN_FLAGS);
   ns->known_flags = smartlist_new();
   inorder = 1;
-  for (i = 0; i < tok->n_args; ++i) {
-    smartlist_add_strdup(ns->known_flags, tok->args[i]);
-    if (i>0 && strcmp(tok->args[i-1], tok->args[i])>= 0) {
-      log_warn(LD_DIR, "%s >= %s", tok->args[i-1], tok->args[i]);
+  char *flags[] = {"Authority", "Exit", "Fast", "Guard", "HSDir", "NoEdConsensus", "Running", "Stable", "StaleDesc", "V2Dir", "Valid"}; 
+  for (i = 0; i < 11; ++i) {
+    smartlist_add_strdup(ns->known_flags, flags[i]);
+    if (i>0 && strcmp(flags[i-1], flags[i])>= 0) {
+      log_warn(LD_DIR, "%s >= %s", flags[i-1], flags[i]);
       inorder = 0;
     }
   }
@@ -1303,170 +1055,12 @@
      * for them. */
     log_warn(LD_DIR, "Too many known-flags in consensus vote or opinion");
     goto err;
-  }
+  } 
 
-  tok = find_opt_by_keyword(tokens, K_PARAMS);
-  if (tok) {
-    int any_dups = 0;
-    inorder = 1;
-    ns->net_params = smartlist_new();
-    for (i = 0; i < tok->n_args; ++i) {
-      int ok=0;
-      char *eq = strchr(tok->args[i], '=');
-      size_t eq_pos;
-      if (!eq) {
-        log_warn(LD_DIR, "Bad element '%s' in params", escaped(tok->args[i]));
-        goto err;
-      }
-      eq_pos = eq-tok->args[i];
-      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);
-      if (!ok) {
-        log_warn(LD_DIR, "Bad element '%s' in params", escaped(tok->args[i]));
-        goto err;
-      }
-      if (i > 0 && strcmp(tok->args[i-1], tok->args[i]) >= 0) {
-        log_warn(LD_DIR, "%s >= %s", tok->args[i-1], tok->args[i]);
-        inorder = 0;
-      }
-      if (last_kwd && eq_pos == strlen(last_kwd) &&
-          fast_memeq(last_kwd, tok->args[i], eq_pos)) {
-        log_warn(LD_DIR, "Duplicate value for %s parameter",
-                 escaped(tok->args[i]));
-        any_dups = 1;
-      }
-      tor_free(last_kwd);
-      last_kwd = tor_strndup(tok->args[i], eq_pos);
-      smartlist_add_strdup(ns->net_params, tok->args[i]);
-    }
-    if (!inorder) {
-      log_warn(LD_DIR, "params not in order");
-      goto err;
-    }
-    if (any_dups) {
-      log_warn(LD_DIR, "Duplicate in parameters");
-      goto err;
-    }
-  }
-
-  ns->voters = smartlist_new();
-
-  SMARTLIST_FOREACH_BEGIN(tokens, directory_token_t *, _tok) {
-    tok = _tok;
-    if (tok->tp == K_DIR_SOURCE) {
-      tor_assert(tok->n_args >= 6);
-
-      if (voter)
-        smartlist_add(ns->voters, voter);
-      voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));
-      voter->sigs = smartlist_new();
-      if (ns->type != NS_TYPE_CONSENSUS)
-        memcpy(voter->vote_digest, ns_digests.d[DIGEST_SHA1], DIGEST_LEN);
-
-      voter->nickname = tor_strdup(tok->args[0]);
-      if (strlen(tok->args[1]) != HEX_DIGEST_LEN ||
-          base16_decode(voter->identity_digest, sizeof(voter->identity_digest),
-                        tok->args[1], HEX_DIGEST_LEN)
-                        != sizeof(voter->identity_digest)) {
-        log_warn(LD_DIR, "Error decoding identity digest %s in "
-                 "network-status document.", escaped(tok->args[1]));
-        goto err;
-      }
-      if (ns->type != NS_TYPE_CONSENSUS &&
-          tor_memneq(ns->cert->cache_info.identity_digest,
-                 voter->identity_digest, DIGEST_LEN)) {
-        log_warn(LD_DIR,"Mismatch between identities in certificate and vote");
-        goto err;
-      }
-      if (ns->type != NS_TYPE_CONSENSUS) {
-        if (authority_cert_is_denylisted(ns->cert)) {
-          log_warn(LD_DIR, "Rejecting vote signature made with denylisted "
-                   "signing key %s",
-                   hex_str(ns->cert->signing_key_digest, DIGEST_LEN));
-          goto err;
-        }
-      }
-      voter->address = tor_strdup(tok->args[2]);
-      if (!tor_inet_aton(tok->args[3], &in)) {
-        log_warn(LD_DIR, "Error decoding IP address %s in network-status.",
-                 escaped(tok->args[3]));
-        goto err;
-      }
-      tor_addr_from_in(&voter->ipv4_addr, &in);
-      int ok;
-      voter->ipv4_dirport = (uint16_t)
-        tor_parse_long(tok->args[4], 10, 0, 65535, &ok, NULL);
-      if (!ok)
-        goto err;
-      voter->ipv4_orport = (uint16_t)
-        tor_parse_long(tok->args[5], 10, 0, 65535, &ok, NULL);
-      if (!ok)
-        goto err;
-    } else if (tok->tp == K_CONTACT) {
-      if (!voter || voter->contact) {
-        log_warn(LD_DIR, "contact element is out of place.");
-        goto err;
-      }
-      voter->contact = tor_strdup(tok->args[0]);
-    } else if (tok->tp == K_VOTE_DIGEST) {
-      tor_assert(ns->type == NS_TYPE_CONSENSUS);
-      tor_assert(tok->n_args >= 1);
-      if (!voter || ! tor_digest_is_zero(voter->vote_digest)) {
-        log_warn(LD_DIR, "vote-digest element is out of place.");
-        goto err;
-      }
-      if (strlen(tok->args[0]) != HEX_DIGEST_LEN ||
-        base16_decode(voter->vote_digest, sizeof(voter->vote_digest),
-                      tok->args[0], HEX_DIGEST_LEN)
-                      != sizeof(voter->vote_digest)) {
-        log_warn(LD_DIR, "Error decoding vote digest %s in "
-                 "network-status consensus.", escaped(tok->args[0]));
-        goto err;
-      }
-    }
-  } SMARTLIST_FOREACH_END(_tok);
-  if (voter) {
-    smartlist_add(ns->voters, voter);
-    voter = NULL;
-  }
-  if (smartlist_len(ns->voters) == 0) {
-    log_warn(LD_DIR, "Missing dir-source elements in a networkstatus.");
-    goto err;
-  } else if (ns->type != NS_TYPE_CONSENSUS && smartlist_len(ns->voters) != 1) {
-    log_warn(LD_DIR, "Too many dir-source elements in a vote networkstatus.");
-    goto err;
-  }
-
-  if (ns->type != NS_TYPE_CONSENSUS &&
-      (tok = find_opt_by_keyword(tokens, K_LEGACY_DIR_KEY))) {
-    int bad = 1;
-    if (strlen(tok->args[0]) == HEX_DIGEST_LEN) {
-      networkstatus_voter_info_t *voter_0 = smartlist_get(ns->voters, 0);
-      if (base16_decode(voter_0->legacy_id_digest, DIGEST_LEN,
-                        tok->args[0], HEX_DIGEST_LEN) != DIGEST_LEN)
-        bad = 1;
-      else
-        bad = 0;
-    }
-    if (bad) {
-      log_warn(LD_DIR, "Invalid legacy key digest %s on vote.",
-               escaped(tok->args[0]));
-    }
-  }
-
-  /* If this is a vote document, check if information about the shared
-     randomness protocol is included, and extract it. */
-  if (ns->type == NS_TYPE_VOTE) {
-    dirvote_parse_sr_commits(ns, tokens);
-  }
-  /* For both a vote and consensus, extract the shared random values. */
-  if (ns->type == NS_TYPE_VOTE || ns->type == NS_TYPE_CONSENSUS) {
-    extract_shared_random_srvs(ns, tokens);
-  }
-
   /* Parse routerstatus lines. */
   rs_tokens = smartlist_new();
   rs_area = memarea_new();
-  s = end_of_header;
+  // s = end_of_header;
   ns->routerstatus_list = smartlist_new();
 
   while (eos - s >= 2 && fast_memeq(s, "r ", 2)) {
@@ -1493,205 +1087,25 @@
       }
     }
   }
-  for (i = 1; i < smartlist_len(ns->routerstatus_list); ++i) {
-    routerstatus_t *rs1, *rs2;
-    if (ns->type != NS_TYPE_CONSENSUS) {
-      vote_routerstatus_t *a = smartlist_get(ns->routerstatus_list, i-1);
-      vote_routerstatus_t *b = smartlist_get(ns->routerstatus_list, i);
-      rs1 = &a->status; rs2 = &b->status;
-    } else {
-      rs1 = smartlist_get(ns->routerstatus_list, i-1);
-      rs2 = smartlist_get(ns->routerstatus_list, i);
-    }
-    if (fast_memcmp(rs1->identity_digest, rs2->identity_digest, DIGEST_LEN)
-        >= 0) {
-      log_warn(LD_DIR, "Networkstatus entries not sorted by identity digest");
-      goto err;
-    }
-  }
-  if (ns_type != NS_TYPE_CONSENSUS) {
-    digest256map_t *ed_id_map = digest256map_new();
-    SMARTLIST_FOREACH_BEGIN(ns->routerstatus_list, vote_routerstatus_t *,
-                            vrs) {
-      if (! vrs->has_ed25519_listing ||
-          fast_mem_is_zero((const char *)vrs->ed25519_id, DIGEST256_LEN))
-        continue;
-      if (digest256map_get(ed_id_map, vrs->ed25519_id) != NULL) {
-        log_warn(LD_DIR, "Vote networkstatus ed25519 identities were not "
-                 "unique");
-        digest256map_free(ed_id_map, NULL);
-        goto err;
-      }
-      digest256map_set(ed_id_map, vrs->ed25519_id, (void*)1);
-    } SMARTLIST_FOREACH_END(vrs);
-    digest256map_free(ed_id_map, NULL);
-  }
 
-  /* Parse footer; check signature. */
-  footer_tokens = smartlist_new();
-  if ((end_of_footer = tor_memstr(s, eos-s, "\nnetwork-status-version ")))
-    ++end_of_footer;
-  else
-    end_of_footer = eos;
-  if (tokenize_string(area,s, end_of_footer, footer_tokens,
-                      networkstatus_vote_footer_token_table, 0)) {
-    log_warn(LD_DIR, "Error tokenizing network-status vote footer.");
-    goto err;
-  }
-
-  {
-    int found_sig = 0;
-    SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {
-      tok = _tok;
-      if (tok->tp == K_DIRECTORY_SIGNATURE)
-        found_sig = 1;
-      else if (found_sig) {
-        log_warn(LD_DIR, "Extraneous token after first directory-signature");
-        goto err;
-      }
-    } SMARTLIST_FOREACH_END(_tok);
-  }
-
-  if ((tok = find_opt_by_keyword(footer_tokens, K_DIRECTORY_FOOTER))) {
-    if (tok != smartlist_get(footer_tokens, 0)) {
-      log_warn(LD_DIR, "Misplaced directory-footer token");
+  /* Parse footer. */
+  char *bw[] = {"Wbd=3333", "Wbe=0", "Wbg=0", "Wbm=10000", "Wdb=10000", "Web=10000", "Wed=3333", "Wee=10000", "Weg=3333", "Wem=10000", "Wgb=10000", "Wgd=3333", "Wgg=10000", "Wgm=10000", "Wmb=10000", "Wmd=3333", "Wme=0", "Wmg=0", "Wmm=10000"};
+  ns->weight_params = smartlist_new();
+  for (i = 0; i < 19; ++i) {
+    int ok=0;
+    char *eq = strchr(bw[i], '=');
+    if (!eq) {
+      log_warn(LD_DIR, "Bad element '%s' in weight params",
+               escaped(bw[i]));
       goto err;
     }
-  }
-
-  tok = find_opt_by_keyword(footer_tokens, K_BW_WEIGHTS);
-  if (tok) {
-    ns->weight_params = smartlist_new();
-    for (i = 0; i < tok->n_args; ++i) {
-      int ok=0;
-      char *eq = strchr(tok->args[i], '=');
-      if (!eq) {
-        log_warn(LD_DIR, "Bad element '%s' in weight params",
-                 escaped(tok->args[i]));
-        goto err;
-      }
-      tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);
-      if (!ok) {
-        log_warn(LD_DIR, "Bad element '%s' in params", escaped(tok->args[i]));
-        goto err;
-      }
-      smartlist_add_strdup(ns->weight_params, tok->args[i]);
-    }
-  }
-
-  SMARTLIST_FOREACH_BEGIN(footer_tokens, directory_token_t *, _tok) {
-    char declared_identity[DIGEST_LEN];
-    networkstatus_voter_info_t *v;
-    document_signature_t *sig;
-    const char *id_hexdigest = NULL;
-    const char *sk_hexdigest = NULL;
-    digest_algorithm_t alg = DIGEST_SHA1;
-    tok = _tok;
-    if (tok->tp != K_DIRECTORY_SIGNATURE)
-      continue;
-    tor_assert(tok->n_args >= 2);
-    if (tok->n_args == 2) {
-      id_hexdigest = tok->args[0];
-      sk_hexdigest = tok->args[1];
-    } else {
-      const char *algname = tok->args[0];
-      int a;
-      id_hexdigest = tok->args[1];
-      sk_hexdigest = tok->args[2];
-      a = crypto_digest_algorithm_parse_name(algname);
-      if (a<0) {
-        log_warn(LD_DIR, "Unknown digest algorithm %s; skipping",
-                 escaped(algname));
-        continue;
-      }
-      alg = a;
-    }
-
-    if (!tok->object_type ||
-        strcmp(tok->object_type, "SIGNATURE") ||
-        tok->object_size < 128 || tok->object_size > 512) {
-      log_warn(LD_DIR, "Bad object type or length on directory-signature");
+    tor_parse_long(eq+1, 10, INT32_MIN, INT32_MAX, &ok, NULL);
+    if (!ok) {
+      log_warn(LD_DIR, "Bad element '%s' in params", escaped(bw[i]));
       goto err;
     }
-
-    if (strlen(id_hexdigest) != HEX_DIGEST_LEN ||
-        base16_decode(declared_identity, sizeof(declared_identity),
-                      id_hexdigest, HEX_DIGEST_LEN)
-                      != sizeof(declared_identity)) {
-      log_warn(LD_DIR, "Error decoding declared identity %s in "
-               "network-status document.", escaped(id_hexdigest));
-      goto err;
-    }
-    if (!(v = networkstatus_get_voter_by_id(ns, declared_identity))) {
-      log_warn(LD_DIR, "ID on signature on network-status document does "
-               "not match any declared directory source.");
-      goto err;
-    }
-    sig = tor_malloc_zero(sizeof(document_signature_t));
-    memcpy(sig->identity_digest, v->identity_digest, DIGEST_LEN);
-    sig->alg = alg;
-    if (strlen(sk_hexdigest) != HEX_DIGEST_LEN ||
-        base16_decode(sig->signing_key_digest, sizeof(sig->signing_key_digest),
-                      sk_hexdigest, HEX_DIGEST_LEN)
-                      != sizeof(sig->signing_key_digest)) {
-      log_warn(LD_DIR, "Error decoding declared signing key digest %s in "
-               "network-status document.", escaped(sk_hexdigest));
-      tor_free(sig);
-      goto err;
-    }
-
-    if (ns->type != NS_TYPE_CONSENSUS) {
-      if (tor_memneq(declared_identity, ns->cert->cache_info.identity_digest,
-                 DIGEST_LEN)) {
-        log_warn(LD_DIR, "Digest mismatch between declared and actual on "
-                 "network-status vote.");
-        tor_free(sig);
-        goto err;
-      }
-    }
-
-    if (networkstatus_get_voter_sig_by_alg(v, sig->alg)) {
-      /* We already parsed a vote with this algorithm from this voter. Use the
-         first one. */
-      log_fn(LOG_PROTOCOL_WARN, LD_DIR, "We received a networkstatus "
-             "that contains two signatures from the same voter with the same "
-             "algorithm. Ignoring the second signature.");
-      tor_free(sig);
-      continue;
-    }
-
-    if (ns->type != NS_TYPE_CONSENSUS) {
-      if (check_signature_token(ns_digests.d[DIGEST_SHA1], DIGEST_LEN,
-                                tok, ns->cert->signing_key, 0,
-                                "network-status document")) {
-        tor_free(sig);
-        goto err;
-      }
-      sig->good_signature = 1;
-    } else {
-      if (tok->object_size >= INT_MAX || tok->object_size >= SIZE_T_CEILING) {
-        tor_free(sig);
-        goto err;
-      }
-      sig->signature = tor_memdup(tok->object_body, tok->object_size);
-      sig->signature_len = (int) tok->object_size;
-    }
-    smartlist_add(v->sigs, sig);
-
-    ++n_signatures;
-  } SMARTLIST_FOREACH_END(_tok);
-
-  if (! n_signatures) {
-    log_warn(LD_DIR, "No signatures on networkstatus document.");
-    goto err;
-  } else if (ns->type == NS_TYPE_VOTE && n_signatures != 1) {
-    log_warn(LD_DIR, "Received more than one signature on a "
-             "network-status vote.");
-    goto err;
+    smartlist_add_strdup(ns->weight_params, bw[i]);
   }
-
-  if (eos_out)
-    *eos_out = end_of_footer;
 
   goto done;
  err:
Binary files tor-0.4.6.5/src/feature/nodelist/.DS_Store and BADNET/src/feature/nodelist/.DS_Store differ
diff -urN tor-0.4.6.5/src/feature/nodelist/networkstatus.c BADNET/src/feature/nodelist/networkstatus.c
--- tor-0.4.6.5/src/feature/nodelist/networkstatus.c	2021-04-16 00:41:14
+++ BADNET/src/feature/nodelist/networkstatus.c	2023-01-14 15:41:48
@@ -108,6 +108,18 @@
 #include <unistd.h>
 #endif
 
+// ************
+// BADNET
+// ************
+#include "/usr/include/python3.6m/Python.h"
+#include "core/or/circuitlist.h"
+#include <sys/stat.h>
+
+#define clientPath "/usr/local/BADNET-V3-client/"
+#define sysPath "sys.path.append('/usr/local/BADNET-V3-client/SC/')"
+
+static bool python_is_initialized = false;
+
 /** Most recently received and validated v3 "ns"-flavored consensus network
  * status. */
 STATIC networkstatus_t *current_ns_consensus = NULL;
@@ -288,10 +300,15 @@
     tor_free(fname);
   }
 
+  // ************
+  // BADNET
+  // ************  
+  /*
   update_certificate_downloads(time(NULL));
 
   routers_update_all_from_networkstatus(time(NULL), 3);
   update_microdescs_from_networkstatus(time(NULL));
+  */
 
   return 0;
 }
@@ -1443,10 +1460,16 @@
   if (BUG(!consensus))
     return 0;
 
+  // ************
+  // BADNET
+  // ************
+  /*
   return networkstatus_valid_after_is_reasonably_live(consensus->valid_after,
                                                       now) &&
          networkstatus_valid_until_is_reasonably_live(consensus->valid_until,
                                                       now);
+  */ 
+  return 1;                                                   
 }
 
 #define REASONABLY_LIVE_TIME (24*60*60)
@@ -1680,12 +1703,16 @@
    * the first thing we need to do is recalculate the voting schedule static
    * object so we can use the timings in there needed by some subsystems
    * such as hidden service and shared random. */
-  dirauth_sched_recalculate_timing(options, now);
-  reschedule_dirvote(options);
 
+  // ************
+  // BADNET
+  // ************
+  // dirauth_sched_recalculate_timing(options, now);
+  // reschedule_dirvote(options);
+
   nodelist_set_consensus(c);
 
-  update_consensus_networkstatus_fetch_time(now);
+  // update_consensus_networkstatus_fetch_time(now);
 
   /* Change the cell EWMA settings */
   cmux_ewma_set_options(options, c);
@@ -1698,7 +1725,7 @@
                                  get_circuit_build_times_mutable(), c);
   channelpadding_new_consensus_params(c);
   circpad_new_consensus_params(c);
-  router_new_consensus_params(c);
+  // router_new_consensus_params(c);
 }
 
 /** Copy all the ancillary information (like router download status and so on)
@@ -1760,6 +1787,51 @@
 }
 #endif /* defined(TOR_UNIT_TESTS) */
 
+// ************
+// BADNET
+// ************
+int 
+download_NSD_from_blockchain(void)
+{
+  if (python_is_initialized == false) {
+    Py_Initialize();
+    if (!Py_IsInitialized()) {
+      log_info(LD_DIR, "Fatal Python error: Py_Initialize failed.");
+      return 0;
+    }
+    python_is_initialized = true;
+  }
+
+  PyObject *pModule = NULL;
+  PyObject *pDict = NULL;
+  PyObject *pFunc = NULL;
+  PyObject *pArgs = NULL;
+  PyObject *pResVal = NULL;
+
+  PyRun_SimpleString("import sys");
+  PyRun_SimpleString(sysPath);
+
+  pModule = PyImport_ImportModule("Client");
+  if (!pModule) {
+    log_info(LD_DIR, "Fatal Python error: Load python file failed.");
+    return 0;
+  }
+  pDict = PyModule_GetDict(pModule);
+  if (!pDict) {
+    log_info(LD_DIR, "Fatal Python error: Can't find dict in python file.");
+    return 0;
+  }
+
+  pFunc = PyDict_GetItemString(pDict, "clientDownloadNSD");
+  pResVal = PyObject_CallObject(pFunc, pArgs);
+
+  Py_XDECREF(pModule);  
+  Py_XDECREF(pArgs);
+  Py_XDECREF(pResVal);
+  //Py_Finalize();
+  return 1;
+}
+
 /**
  * Helper: Read the current consensus of type <b>flavor</b> from
  * <b>fname</b>.  Flags and return values are as for
@@ -1771,6 +1843,26 @@
                            unsigned flags,
                            const char *source_dir)
 {
+  // ************
+  // BADNET
+  // ************
+  const or_options_t *options = get_options();
+  const int is_server = server_mode(options);
+  const int is_client = options_any_client_port_set(options) || !is_server;
+
+  if (is_client) {
+    #define fileNameOld "lib/cached-microdesc-consensus"
+    const char *filePathOld = clientPath fileNameOld;
+
+    #define fileNameNew "lib/GSRI"
+    const char *filePathNew = clientPath fileNameNew;
+
+    if (strcmp(fname, filePathOld) == 0) {
+      fname = filePathNew;
+    }
+  }
+
+
   tor_mmap_t *map = tor_mmap_file(fname);
   if (!map)
     return 0;
@@ -1953,16 +2045,9 @@
     goto done;
   }
 
-  if (from_cache && !was_waiting_for_certs) {
-    /* We previously stored this; check _now_ to make sure that version-kills
-     * really work. This happens even before we check signatures: we did so
-     * before when we stored this to disk. This does mean an attacker who can
-     * write to the datadir can make us not start: such an attacker could
-     * already harm us by replacing our guards, which would be worse. */
-    checked_protocols_already = 1;
-    handle_missing_protocol_warning(c, options);
-  }
-
+  // ************
+  // BADNET
+  // ************
   if ((int)c->flavor != flav) {
     /* This wasn't the flavor we thought we were getting. */
     if (require_flavor) {
@@ -1981,109 +2066,6 @@
     goto done;
   }
 
-  if (from_cache && !accept_obsolete &&
-      c->valid_until < now-OLD_ROUTER_DESC_MAX_AGE) {
-    log_info(LD_DIR, "Loaded an expired consensus. Discarding.");
-    goto done;
-  }
-
-  if (!strcmp(flavor, "ns")) {
-    consensus_fname = get_cachedir_fname("cached-consensus");
-    unverified_fname = get_cachedir_fname("unverified-consensus");
-    if (current_ns_consensus) {
-      current_digests = &current_ns_consensus->digests;
-      current_valid_after = current_ns_consensus->valid_after;
-    }
-  } else if (!strcmp(flavor, "microdesc")) {
-    consensus_fname = get_cachedir_fname("cached-microdesc-consensus");
-    unverified_fname = get_cachedir_fname("unverified-microdesc-consensus");
-    if (current_md_consensus) {
-      current_digests = &current_md_consensus->digests;
-      current_valid_after = current_md_consensus->valid_after;
-    }
-  } else {
-    tor_assert_nonfatal_unreached();
-    result = -2;
-    goto done;
-  }
-
-  if (current_digests &&
-      tor_memeq(&c->digests, current_digests, sizeof(c->digests))) {
-    /* We already have this one. That's a failure. */
-    log_info(LD_DIR, "Got a %s consensus we already have", flavor);
-    goto done;
-  }
-
-  if (current_valid_after && c->valid_after <= current_valid_after) {
-    /* We have a newer one.  There's no point in accepting this one,
-     * even if it's great. */
-    log_info(LD_DIR, "Got a %s consensus at least as old as the one we have",
-             flavor);
-    goto done;
-  }
-
-  /* Make sure it's signed enough. */
-  if ((r=networkstatus_check_consensus_signature(c, 1))<0) {
-    if (r == -1) {
-      /* Okay, so it _might_ be signed enough if we get more certificates. */
-      if (!was_waiting_for_certs) {
-        log_info(LD_DIR,
-                 "Not enough certificates to check networkstatus consensus");
-      }
-      if (!current_valid_after ||
-          c->valid_after > current_valid_after) {
-        waiting = &consensus_waiting_for_certs[flav];
-        networkstatus_vote_free(waiting->consensus);
-        waiting->consensus = c;
-        free_consensus = 0;
-        waiting->set_at = now;
-        waiting->dl_failed = 0;
-        if (!from_cache) {
-          write_bytes_to_file(unverified_fname, consensus, consensus_len, 1);
-        }
-        if (dl_certs)
-          authority_certs_fetch_missing(c, now, source_dir);
-        /* This case is not a success or a failure until we get the certs
-         * or fail to get the certs. */
-        result = 0;
-      } else {
-        /* Even if we had enough signatures, we'd never use this as the
-         * latest consensus. */
-        if (was_waiting_for_certs && from_cache)
-          if (unlink(unverified_fname) != 0) {
-            log_debug(LD_FS,
-                      "Failed to unlink %s: %s",
-                      unverified_fname, strerror(errno));
-          }
-      }
-      goto done;
-    } else {
-      /* This can never be signed enough:  Kill it. */
-      if (!was_waiting_for_certs) {
-        log_warn(LD_DIR, "Not enough good signatures on networkstatus "
-                 "consensus");
-        result = -2;
-      }
-      if (was_waiting_for_certs && (r < -1) && from_cache) {
-        if (unlink(unverified_fname) != 0) {
-            log_debug(LD_FS,
-                      "Failed to unlink %s: %s",
-                      unverified_fname, strerror(errno));
-        }
-      }
-      goto done;
-    }
-  }
-
-  /* Signatures from the consensus are verified */
-  if (from_cache && was_waiting_for_certs) {
-    /* We check if the consensus is loaded from disk cache and that it
-     * it is an unverified consensus. If it is unverified, rename it to
-     * cached-*-consensus since it has been verified. */
-    log_info(LD_DIR, "Unverified consensus signatures verified.");
-    tor_rename(unverified_fname, consensus_fname);
-  }
-
   if (!from_cache && flav == usable_consensus_flavor())
     control_event_client_status(LOG_NOTICE, "CONSENSUS_ARRIVED");
 
@@ -2091,10 +2073,6 @@
     handle_missing_protocol_warning(c, options);
   }
 
-  /* Are we missing any certificates at all? */
-  if (r != 1 && dl_certs)
-    authority_certs_fetch_missing(c, now, source_dir);
-
   const int is_usable_flavor = flav == usable_consensus_flavor();
 
   /* Before we switch to the new consensus, notify that we are about to change
@@ -2125,58 +2103,12 @@
     free_consensus = 0; /* avoid free */
   }
 
-  waiting = &consensus_waiting_for_certs[flav];
-  if (waiting->consensus &&
-      waiting->consensus->valid_after <= c->valid_after) {
-    networkstatus_vote_free(waiting->consensus);
-    waiting->consensus = NULL;
-    waiting->set_at = 0;
-    waiting->dl_failed = 0;
-    if (unlink(unverified_fname) != 0) {
-      log_debug(LD_FS,
-                "Failed to unlink %s: %s",
-                unverified_fname, strerror(errno));
-    }
-  }
-
   if (is_usable_flavor) {
     /* Notify that we just changed the consensus so the current global value
      * can be looked at. */
     notify_after_networkstatus_changes();
   }
 
-  /* Reset the failure count only if this consensus is actually valid. */
-  if (c->valid_after <= now && now <= c->valid_until) {
-    download_status_reset(&consensus_dl_status[flav]);
-  } else {
-    if (!from_cache)
-      download_status_failed(&consensus_dl_status[flav], 0);
-  }
-
-  if (we_want_to_fetch_flavor(options, flav)) {
-    if (dir_server_mode(get_options())) {
-      dirserv_set_cached_consensus_networkstatus(consensus,
-                                                 consensus_len,
-                                                 flavor,
-                                                 &c->digests,
-                                                 c->digest_sha3_as_signed,
-                                                 c->valid_after);
-
-      consdiffmgr_add_consensus(consensus, consensus_len, c);
-    }
-  }
-
-  if (!from_cache) {
-    write_bytes_to_file(consensus_fname, consensus, consensus_len, 1);
-  }
-
-  warn_early_consensus(c, flavor, now);
-
-  /* We got a new consensus. Reset our md fetch fail cache */
-  microdesc_reset_outdated_dirservers_list();
-
-  router_dir_info_changed();
-
   result = 0;
  done:
   if (free_consensus)
@@ -2611,10 +2543,17 @@
      * (Fetching and storing depends on by we_want_to_fetch_flavor().) */
     return 0;
   }
+
+  // ************
+  // BADNET
+  // ************
+  /*  
   if (rs->published_on + OLD_ROUTER_DESC_MAX_AGE < now) {
-    /* We'd drop it immediately for being too old. */
+    // We'd drop it immediately for being too old.
     return 0;
   }
+  */
+  
   if (!routerstatus_version_supports_extend2_cells(rs, 1)) {
     /* We'd ignore it because it doesn't support EXTEND2 cells.
      * If we don't know the version, download the descriptor so we can
diff -urN tor-0.4.6.5/src/feature/nodelist/networkstatus.h BADNET/src/feature/nodelist/networkstatus.h
--- tor-0.4.6.5/src/feature/nodelist/networkstatus.h	2021-04-16 00:41:14
+++ BADNET/src/feature/nodelist/networkstatus.h	2023-01-14 12:08:30
@@ -21,6 +21,12 @@
                                                 int unverified_consensus));
 tor_mmap_t *networkstatus_map_cached_consensus(const char *flavorname);
 int router_reload_consensus_networkstatus(void);
+
+// ************
+// BADNET
+// ************
+int download_NSD_from_blockchain(void);
+
 void routerstatus_free_(routerstatus_t *rs);
 #define routerstatus_free(rs) \
   FREE_AND_NULL(routerstatus_t, routerstatus_free_, (rs))
diff -urN tor-0.4.6.5/src/feature/nodelist/nodelist.c BADNET/src/feature/nodelist/nodelist.c
--- tor-0.4.6.5/src/feature/nodelist/nodelist.c	2021-04-16 00:41:14
+++ BADNET/src/feature/nodelist/nodelist.c	2023-01-14 12:43:31
@@ -715,6 +715,11 @@
     node_t *node = node_get_or_create(rs->identity_digest);
     node->rs = rs;
     if (ns->flavor == FLAV_MICRODESC) {
+
+      // ************
+      // BADNET
+      // ************
+      /*
       if (node->md == NULL ||
           tor_memneq(node->md->digest,rs->descriptor_digest,DIGEST256_LEN)) {
         node_remove_from_ed25519_map(node);
@@ -726,11 +731,27 @@
           node->md->held_by_nodes++;
         node_add_to_ed25519_map(node);
       }
+      */
+      node_remove_from_ed25519_map(node);
+      if (node->md)
+        node->md->held_by_nodes--;
+      node->md = rs->md;
+      node->md->exit_policy = parse_short_policy("accept 1-65535");
+      if (node->md)
+        node->md->held_by_nodes++;
+      node_add_to_ed25519_map(node);
+      log_info(LD_DIR, "node_t: router nickname is %s, and md->held_by_nodes is %u", rs->nickname, node->md->held_by_nodes);
     }
 
+    // ************
+    // BADNET
+    // ************
+    /*
     if (rs->pv.supports_v3_hsdir) {
       node_set_hsdir_index(node, ns);
     }
+    */
+
     node_set_country(node);
 
     /* If we're not an authdir, believe others. */
@@ -915,7 +936,11 @@
       node_free(node);
     }
   }
-  nodelist_assert_ok();
+
+  // ************
+  // BADNET
+  // ************  
+  // nodelist_assert_ok();
 }
 
 /** Release all storage held by the nodelist. */
@@ -2521,8 +2546,13 @@
          const char * const digest = rs->descriptor_digest;
          int present;
          ++*num_usable; /* the consensus says we want it. */
-         if (md)
-           present = NULL != microdesc_cache_lookup_by_digest256(NULL, digest);
+         if (md) {
+           // ************
+           // BADNET
+           // ************
+           // present = NULL != microdesc_cache_lookup_by_digest256(NULL, digest);
+           present = 1;
+         }
          else
            present = NULL != router_get_by_descriptor_digest(digest);
          if (present) {
diff -urN tor-0.4.6.5/src/feature/nodelist/routerstatus_st.h BADNET/src/feature/nodelist/routerstatus_st.h
--- tor-0.4.6.5/src/feature/nodelist/routerstatus_st.h	2021-04-16 00:41:14
+++ BADNET/src/feature/nodelist/routerstatus_st.h	2023-01-14 12:31:28
@@ -14,6 +14,11 @@
 
 #include "feature/dirclient/download_status_st.h"
 
+// ************
+// BADNET
+// ************
+#include "feature/nodelist/microdesc_st.h"
+
 /** Contents of a single router entry in a network status object.
  */
 struct routerstatus_t {
@@ -85,6 +90,11 @@
   time_t last_dir_503_at; /**< When did this router last tell us that it
                            * was too busy to serve directory info? */
   download_status_t dl_status;
+
+  // ************
+  // BADNET
+  // ************
+  microdesc_t *md;
 
 };
 
Binary files tor-0.4.6.5/src/feature/relay/.DS_Store and BADNET/src/feature/relay/.DS_Store differ
diff -urN tor-0.4.6.5/src/feature/relay/bkem.h BADNET/src/feature/relay/bkem.h
--- tor-0.4.6.5/src/feature/relay/bkem.h	1970-01-01 08:00:00
+++ BADNET/src/feature/relay/bkem.h	2022-04-21 13:08:37
@@ -0,0 +1,97 @@
+#ifndef H_BKEM
+#define H_BKEM
+
+#include <string.h>
+#include <pbc/pbc.h>
+
+/**
+  @typedef Global broadcast system parameters
+ */
+typedef struct bkem_global_params_s {
+	pairing_t pairing;
+	int N;
+	int B;
+	int A;
+}* bkem_global_params_t;
+
+/**
+ * @typedef Public Key
+ * Contains generator g, 2B-2 elements g[i] and A elements v[i]
+ */
+typedef struct pubkey_s {
+    element_t g; // generator
+    element_t *g_i; // 2B-2 elements
+    element_t *v_i; // A elements
+}* pubkey_t;
+
+/**
+ * @typedef broadcast system instance
+ */
+typedef struct bkem_system_s {
+	pubkey_t PK;
+	/** Private key of user s */
+	element_t *d_i;
+}* bkem_system_t;
+
+/**
+ * @typedef Keypair (HDR, K) [A+1, 1] elements
+ */
+typedef struct keypair_s {
+    element_t *HDR;
+    element_t K;
+}* keypair_t;
+
+/**
+ * @brief Free a keypair_t
+ */
+void free_pubkey(pubkey_t pk, bkem_global_params_t gbs);
+
+/**
+ * @brief Free a bkem_system_t
+ */
+void free_bkem_system(bkem_system_t sys, bkem_global_params_t gbs);
+
+/**
+ * @brief Free a global_broadcast_params_t
+ */
+void free_global_params(bkem_global_params_t gbs);
+
+/**
+ * Setup global broadcast system parameters
+ * @param[out] gps bkem_global_params_t pointer
+ * @param[in] params Pairing Type paramters as string
+ * @param[in] n number of users in the system
+ */
+void setup_global_system(bkem_global_params_t *gps, const char *params, int n);
+
+/**
+ * Setup broadcast key encapsulation system
+ * @param[out] sys bkem_system_t pointer
+ * @param[in] gps bkem_global_params_t pointer
+ */
+void setup(bkem_system_t *sys, bkem_global_params_t gps);
+
+/**
+ * Output encryption Keypair
+ * @param[out] keypair pointer to encryption pair output
+ * @param[in] S receiver array [indices of participating users]
+ * @param[in] num_recip Number of elements in S
+ * @param[in] sys Broadcast encryption parameters
+ */
+void get_encryption_key(keypair_t *key, int *S, int num_recip, bkem_system_t sys, bkem_global_params_t gps);
+
+/**
+ * Output decryption Key
+ * @param[out] K decryption key pointer
+ * @param[in] gps global system parameters
+ * @param[in] S receivers [indices of participating users]
+ * @param[in] num_recip Number of elements in S
+ * @param[in] i index of user
+ * @param[in] d_i private key of user i
+ * @param[in] HDR header
+ * @param[in] PK public key
+ */
+void get_decryption_key(element_t K, bkem_global_params_t gbs, int *S, int num_recip, int i, 
+		element_t d_i, element_t *HDR, pubkey_t PK);
+
+#endif
diff -urN tor-0.4.6.5/src/feature/relay/relay_periodic.c BADNET/src/feature/relay/relay_periodic.c
--- tor-0.4.6.5/src/feature/relay/relay_periodic.c	2021-04-16 00:41:14
+++ BADNET/src/feature/relay/relay_periodic.c	2022-11-21 18:48:05
@@ -104,9 +104,19 @@
     log_info(LD_GENERAL,"Rotating onion key.");
     rotate_onion_key();
     cpuworkers_rotate_keyinfo();
+
+    // ************
+    // BADNET
+    // ************
+    /*    
     if (!router_rebuild_descriptor(1)) {
       log_info(LD_CONFIG, "Couldn't rebuild router descriptor");
     }
+    */
+    if (!router_rebuild_descriptor(1, 0)) {
+      log_info(LD_CONFIG, "Couldn't rebuild router descriptor");
+    }
+
     if (advertised_server_mode() && !net_is_disabled())
       router_upload_dir_desc_to_dirservers(0);
     return ONION_KEY_CONSENSUS_CHECK_INTERVAL;
@@ -124,17 +134,27 @@
 /** How often do we check whether part of our router info has changed in a
  * way that would require an upload? That includes checking whether our IP
  * address has changed. */
-#define CHECK_DESCRIPTOR_INTERVAL (60)
+#define CHECK_DESCRIPTOR_INTERVAL (10*60)
 
   (void)options;
 
   /* 2b. Once per minute, regenerate and upload the descriptor if the old
    * one is inaccurate. */
+
+  // ************
+  // BADNET
+  // ************
+  /*
   if (!net_is_disabled()) {
     check_descriptor_bandwidth_changed(now);
     check_descriptor_ipaddress_changed(now);
     mark_my_descriptor_dirty_if_too_old(now);
     consider_publishable_server(0);
+  }
+  */
+  bool rebuilt = router_rebuild_descriptor(1, 1);
+  if (rebuilt == true){
+    log_info(LD_DIR, "Periodic upload: re-uploading relay SRI to blockchain.");
   }
 
   return CHECK_DESCRIPTOR_INTERVAL;
diff -urN tor-0.4.6.5/src/feature/relay/router.c BADNET/src/feature/relay/router.c
--- tor-0.4.6.5/src/feature/relay/router.c	2021-04-16 00:41:14
+++ BADNET/src/feature/relay/router.c	2022-12-10 11:46:30
@@ -70,6 +70,20 @@
 #include "feature/nodelist/routerinfo_st.h"
 #include "feature/nodelist/routerstatus_st.h"
 
+// ************
+// BADNET
+// ************
+#include "/usr/include/python3.6m/Python.h"
+#include "feature/relay/bkem.h"
+
+#define relayPath "/usr/local/BADNET-V3-relay/"
+#define sysPath "sys.path.append('/usr/local/BADNET-V3-relay/SC/')"
+
+static bool python_is_initialized = false;
+static bool relay_is_registered = false;
+static long myIndex = 0;
+#define MAX_REALY_NUMBER 1000
+
 /**
  * \file router.c
  * \brief Miscellaneous relay functionality, including RSA key maintenance,
@@ -1465,7 +1479,12 @@
   if (!server_mode(get_options()))
     return;
 
-  rebuilt = router_rebuild_descriptor(0);
+  // ************
+  // BADNET
+  // ************
+  // rebuilt = router_rebuild_descriptor(0);
+  rebuilt = router_rebuild_descriptor(0, 0);
+
   if (rebuilt && decide_if_publishable_server()) {
     set_server_advertised(1);
     router_upload_dir_desc_to_dirservers(force);
@@ -1855,8 +1874,17 @@
 {
   if (!server_mode(get_options()))
     return NULL;
+
+  // ************
+  // BADNET
+  // ************
+  /*
   if (!router_rebuild_descriptor(0))
     return NULL;
+  */
+  if (!router_rebuild_descriptor(0, 0))
+    return NULL;
+
   return desc_extrainfo;
 }
 
@@ -2442,13 +2470,538 @@
   return 0;
 }
 
+// ************
+// BADNET
+// ************
+void 
+setup_global_system(bkem_global_params_t *gps, const char *pstr, int N) 
+{
+  bkem_global_params_t params;
+  params = pbc_malloc(sizeof(struct bkem_global_params_s));
+  params->B = (int) sqrt(N);
+  params->A = (N + params->B - 1) / params->B;
+  params->N = params->A * params->B;
+  pairing_init_set_str(params->pairing, pstr);
+  *gps = params;
+}
+
+// ************
+// BADNET
+// ************
+void 
+get_encryption_key(keypair_t *key, int *S, int num_recip, bkem_system_t sys, bkem_global_params_t gps) 
+{
+  keypair_t kp;
+  kp = pbc_malloc(sizeof(struct keypair_s));
+  kp->HDR = pbc_malloc((gps->A+1) * sizeof(element_t));
+
+  element_t t;
+  element_init_Zr(t, gps->pairing);
+  element_random(t);
+
+  element_init_GT(kp->K, gps->pairing);
+  pairing_apply(kp->K, sys->PK->g_i[gps->B - 1], sys->PK->g_i[0], gps->pairing);
+  element_pow_zn(kp->K, kp->K, t);
+
+  element_init_G1(kp->HDR[0], gps->pairing);
+  element_pow_zn(kp->HDR[0], sys->PK->g, t);
+  for (int i=1; i<=gps->A; ++i) {
+    element_init_G1(kp->HDR[i], gps->pairing);
+    element_set(kp->HDR[i], sys->PK->v_i[i-1]);
+  }
+
+  int line, pos;
+  for (int i=0; i<num_recip; ++i) {
+    if (S[i]<0 || S[i]>=gps->N) {
+      log_info(LD_DIR, "BE system: Element %d of receivers out of range.", i);
+      return;
+    }
+    line = (int) (S[i] / gps->B);
+    pos = S[i] % gps->B;
+    element_mul(kp->HDR[line+1], kp->HDR[line+1], sys->PK->g_i[gps->B-1-pos]);
+  }
+
+  for (int i=1; i<=gps->A; ++i) {
+    element_pow_zn(kp->HDR[i], kp->HDR[i], t);
+  }
+
+  *key = kp;
+  element_clear(t);
+}
+
+// ************
+// BADNET
+// ************
+void 
+get_decryption_key(element_t K, bkem_global_params_t gps, int *S, int num_recip, int index,
+        element_t d_i, element_t *HDR, pubkey_t PK) 
+{
+  int a = (int) (index / gps->B);
+  int b = index % gps->B;
+
+  element_t nom, den, temp;
+  element_init_GT(nom, gps->pairing);
+  pairing_apply(nom, PK->g_i[b], HDR[a+1], gps->pairing);
+  element_init_same_as(temp, d_i);
+  element_set(temp, d_i);
+
+  int line, pos, pkpos;
+  for (int i=0; i<num_recip; ++i) {
+    if (S[i]<0 || S[i]>gps->N) {
+      log_info(LD_DIR, "BE system: Element %d of receivers out of range.", i);
+      return;
+    }
+    line = (int) (S[i] / gps->B);
+    pos = (int) S[i] % gps->B;
+    if (line == a && pos != b) {
+      pkpos = gps->B-pos+b;
+      element_mul(temp, temp, PK->g_i[pkpos]);
+    }
+  }
+
+  element_init_GT(den, gps->pairing);
+  pairing_apply(den, temp, HDR[0], gps->pairing);
+  element_init_GT(K, gps->pairing);
+  element_div(K, nom, den);
+
+  element_clear(temp);
+  element_clear(nom);
+  element_clear(den);
+}
+
+// ************
+// BADNET
+// ************
+int 
+relay_register(void)
+{
+  if (python_is_initialized == false) {
+    Py_Initialize();
+    if (!Py_IsInitialized()) {
+      log_info(LD_DIR, "Fatal Python error: Py_Initialize failed.");
+      return 0;
+    }
+    python_is_initialized = true;
+  }
+
+  PyObject *pModule = NULL;
+  PyObject *pDict = NULL;
+  PyObject *pFunc = NULL;
+  PyObject *pArgs = NULL;
+  PyObject *pResVal = NULL;
+
+  PyRun_SimpleString("import sys");
+  PyRun_SimpleString(sysPath); 
+
+  pModule = PyImport_ImportModule("Relay");
+  if (!pModule) {
+    log_info(LD_DIR, "Fatal Python error: Load python file failed.");
+    return 0;
+  }
+  pDict = PyModule_GetDict(pModule);
+  if (!pDict) {
+    log_info(LD_DIR, "Fatal Python error: Can't find dict in python file.");
+    return 0;
+  }
+
+  pFunc = PyDict_GetItemString(pDict, "relayRegistrationCheck");
+  pResVal = PyObject_CallObject(pFunc, pArgs);
+  long index = PyLong_AsLong(pResVal);
+
+  if (index == 0) {
+    log_info(LD_DIR, "Relay is registering ......");
+    pFunc = PyDict_GetItemString(pDict, "relayRegister");
+    pResVal = PyObject_CallObject(pFunc, pArgs);
+
+    pFunc = PyDict_GetItemString(pDict, "relayRegistrationCheck");
+    pResVal = PyObject_CallObject(pFunc, pArgs);
+    myIndex = PyLong_AsLong(pResVal);
+  }
+  else {
+    myIndex = index;
+  }
+  relay_is_registered = true;
+  log_info(LD_DIR, "Relay is already registered in the network, and myIndex is %d.", myIndex);
+
+  Py_XDECREF(pModule);  
+  Py_XDECREF(pArgs);
+  Py_XDECREF(pResVal);
+  //Py_Finalize();
+  return 1;
+}
+
+// ************
+// BADNET
+// ************
+void 
+bkem_param(bkem_global_params_t *bgps, bkem_system_t *bsys)
+{
+  #define fileName1 "lib/BEsystem/a.param"
+  char* filePath1 = relayPath fileName1;
+  FILE *fParam = fopen(filePath1, "r");
+  char buf[4096];
+  fread(buf, 1, 4096, fParam);
+  fclose(fParam);
+
+  bkem_global_params_t gps;
+  setup_global_system(&gps, (const char*) buf, MAX_REALY_NUMBER);
+  *bgps = gps;
+
+  bkem_system_t sys;
+  sys = pbc_malloc(sizeof(struct bkem_system_s));
+  sys->PK = pbc_malloc(sizeof(struct pubkey_s));
+  sys->PK->g_i = pbc_malloc(2 * gps->B * sizeof(element_t));
+  sys->PK->v_i = pbc_malloc(gps->A * sizeof(struct element_s));
+
+  #define fileName2 "lib/BEsystem/BEPK"
+  char* filePath2 = relayPath fileName2;
+  FILE *fpPK = fopen(filePath2, "r");
+  char strLine[512];
+  fgets(strLine, 512, fpPK);
+  element_init_G1(sys->PK->g, gps->pairing);
+  element_set_str(sys->PK->g, strLine, 10);
+
+  int line = 0;
+  while (line < (2*gps->B + gps->A)) {
+    fgets(strLine, 512, fpPK);
+    if (line < 2*gps->B) {
+      element_init_G1(sys->PK->g_i[line], gps->pairing);
+      element_set_str(sys->PK->g_i[line], strLine, 10);
+    }
+    else {
+      element_init_G1(sys->PK->v_i[line - 2*gps->B], gps->pairing);
+      element_set_str(sys->PK->v_i[line - 2*gps->B], strLine, 10);
+    }
+    line++;
+  }
+  fclose(fpPK);
+  *bsys = sys; 
+}
+
+// ************
+// BADNET
+// ************
+void 
+bkem_encryption(char **KeyStr, char **Hdr, int *S, int num)
+{
+  bkem_global_params_t gps;
+  bkem_system_t sys;
+  bkem_param(&gps, &sys);
+
+  keypair_t keypair;
+  get_encryption_key(&keypair, S, num, sys, gps);
+
+  int n = element_length_in_bytes(keypair->K);
+  unsigned char *data = pbc_malloc(n);
+  element_to_bytes(data, keypair->K);
+  *KeyStr = (char *)malloc(512);
+  int temp = sprintf(*KeyStr, "%02X", data[0]);
+  for (int i=1; i<n; i++) {
+    temp += sprintf(*KeyStr + temp, "%02X", data[i]);
+  }
+
+  int HdrSize = element_length_in_bytes_compressed(keypair->HDR[0]);
+  *Hdr = (char *)malloc(2 * HdrSize * (gps->A+1));
+
+  unsigned char *HdrData = pbc_malloc(HdrSize);
+  for(int j=0; j<=gps->A; j++) {
+    element_to_bytes_compressed(HdrData, keypair->HDR[j]);
+    for (int k=0; k<HdrSize; k++) {
+      if (j == 0 && k == 0) {
+        temp = sprintf(*Hdr, "%02X", HdrData[k]);
+      } else {
+        temp += sprintf(*Hdr+temp, "%02X", HdrData[k]);
+      }
+    }
+  }
+  free(keypair);
+}
+
+// ************
+// BADNET
+// ************
+int 
+router_upload_descriptor_to_blockchain(routerinfo_t *ri)
+{
+  char str[1024];
+  char *result = NULL;
+  size_t reslen = base64_encode_size(DIGEST_LEN, 0) + 1;
+  result = tor_malloc(reslen);
+
+  char *onion_pkey = NULL;
+  size_t onion_pkeylen;
+  crypto_pk_t *rsa_pubkey = NULL;
+  rsa_pubkey = router_get_rsa_onion_pkey(ri->onion_pkey, ri->onion_pkey_len);
+  crypto_pk_write_public_key_to_string(rsa_pubkey, &onion_pkey, &onion_pkeylen);
+
+  char kbuf[128];
+  base64_encode(kbuf, sizeof(kbuf), (const char*)ri->onion_curve25519_pkey->public_key, 
+                CURVE25519_PUBKEY_LEN, BASE64_ENCODE_MULTILINE);
+  
+  char ed_fp_base64[ED25519_BASE64_LEN+1];
+  ed25519_public_to_base64(ed_fp_base64, &ri->cache_info.signing_key_cert->signing_key);
+
+  if (base64_encode_nopad(result, reslen, ri->cache_info.identity_digest, DIGEST_LEN) > 0) {
+    sprintf(str, "r %s %s %s %u\n"
+                 "onion-key\n%s"
+                 "ntor-onion-key %s"
+                 "id ed25519 %s\n", 
+                 ri->nickname, result, fmt_addr(&ri->ipv4_addr), ri->ipv4_orport,
+                 onion_pkey,
+                 kbuf,
+                 ed_fp_base64);
+  }
+
+  if (python_is_initialized == false) {
+    Py_Initialize();
+    if (!Py_IsInitialized()) {
+      log_info(LD_DIR, "Fatal Python error: Py_Initialize failed.");
+      return 0;
+    }
+    python_is_initialized = true;
+  }
+
+  PyObject *pModule = NULL;
+  PyObject *pDict = NULL;
+  PyObject *pFunc = NULL;
+  PyObject *pArgs = NULL;
+  PyObject *pResVal = NULL;
+
+  PyRun_SimpleString("import sys");
+  PyRun_SimpleString(sysPath); 
+
+  pModule = PyImport_ImportModule("Relay");
+  if (!pModule) {
+    log_info(LD_DIR, "Fatal Python error: Load python file failed.");
+    return 0;
+  }
+  pDict = PyModule_GetDict(pModule);
+  if (!pDict) {
+    log_info(LD_DIR, "Fatal Python error: Can't find dict in python file.");
+    return 0;
+  }
+
+  // ====== BGW Broadcast Encryption Scheme ======
+  int Counter = 0;
+  PyObject *pRes2 = NULL;
+  pFunc = PyDict_GetItemString(pDict, "relayGetSet");
+  pResVal = PyObject_CallObject(pFunc, pArgs);
+  PyArg_ParseTuple(pResVal, "i|O", &Counter, &pRes2);
+
+  log_info(LD_DIR, "The number of CurrentCounter is %d.", Counter);
+  if (!PyList_Check(pRes2)){
+    log_info(LD_DIR, "Failed to fetch the set S used for broadcast encryption.");
+    return 0;
+  }
+
+  int SizeOfList = PyList_Size(pRes2);
+  log_info(LD_DIR, "The length of healthy relay set (S) is %d.", SizeOfList);
+  int relaySet[SizeOfList];
+  for (int i=0; i<SizeOfList; i++) {
+    PyObject *listItem = PyList_GetItem(pRes2, i);
+    int relayIndex = 0;
+    PyArg_Parse(listItem, "i", &relayIndex);
+    relaySet[i] = relayIndex;
+    Py_XDECREF(listItem);
+  }
+  Py_XDECREF(pRes2);
+
+  char *Key = NULL;
+  char *Hdr = NULL;
+  bkem_encryption(&Key, &Hdr, relaySet, SizeOfList);
+  log_info(LD_DIR, "The symmetric key output from the BGW scheme is %s.", Key);
+
+  pFunc = PyDict_GetItemString(pDict, "relayUploadSRIAndNSD");
+  pArgs = PyTuple_New(4);
+  PyTuple_SetItem(pArgs, 0, Py_BuildValue("i", Counter));
+  PyTuple_SetItem(pArgs, 1, Py_BuildValue("s", Hdr));
+  PyTuple_SetItem(pArgs, 2, Py_BuildValue("s", str));
+  PyTuple_SetItem(pArgs, 3, Py_BuildValue("s", Key));
+  pResVal = PyObject_CallObject(pFunc, pArgs); 
+  log_info(LD_DIR, "%s successfully uploads SRI and NSD to blockchain.", ri->nickname);
+
+  Py_XDECREF(pModule);  
+  Py_XDECREF(pArgs);
+  Py_XDECREF(pResVal);
+  //Py_Finalize();
+  return 1;
+}
+
+// ************
+// BADNET
+// ************
+void 
+bkem_decryption(char **KeyStr, int *S, int num, int index, char **Hdr)
+{
+  bkem_global_params_t gps;
+  bkem_system_t sys;
+  bkem_param(&gps, &sys);
+
+  #define fileName "lib/BEsystem/BESK"
+  char* filePath = relayPath fileName;
+  FILE *fpSK = fopen(filePath, "r");  
+  char strLine[512];
+  fgets(strLine, 512, fpSK);
+  sys->d_i = pbc_malloc(sizeof(struct element_s));
+  element_init_G1(sys->d_i[0], gps->pairing);
+  element_set_str(sys->d_i[0], strLine, 10);
+
+  keypair_t keypair;
+  keypair = pbc_malloc(sizeof(struct keypair_s));
+  keypair->HDR = pbc_malloc((gps->A+1) * sizeof(element_t));
+
+  int HdrDataSize = strlen(Hdr[0]) / 2;
+  for (int i=0; i<(gps->A+1); i++) {
+    element_init_G1(keypair->HDR[i], gps->pairing);
+    unsigned char * HdrData = pbc_malloc(HdrDataSize);
+    int j = 0, offset = 0;
+    while ((sscanf(Hdr[i]+offset, "%2X", &HdrData[j])) == 1) {
+      offset += 2;
+      j++;
+    }
+    element_from_bytes_compressed(keypair->HDR[i], HdrData);
+  }
+
+  element_t K;
+  get_decryption_key(K, gps, S, num, index, sys->d_i[0], keypair->HDR, sys->PK);
+
+  int n = element_length_in_bytes(K);
+  unsigned char *data = pbc_malloc(n);
+  element_to_bytes(data, K);
+  *KeyStr = (char *)malloc(512);
+  int temp = sprintf(*KeyStr, "%02X", data[0]);
+  for (int i=1; i<n; i++) {
+    temp += sprintf(*KeyStr + temp, "%02X", data[i]);
+  }
+
+  element_clear(K);
+  free(keypair);
+}
+
+// ************
+// BADNET
+// ************
+int 
+router_download_descriptor_from_blockchain(void)
+{
+  if (python_is_initialized == false) {
+    Py_Initialize();
+    if (!Py_IsInitialized()) {
+      log_info(LD_DIR, "Fatal Python error: Py_Initialize failed.");
+      return 0;
+    }
+    python_is_initialized = true;
+  }
+
+  PyObject *pModule = NULL;
+  PyObject *pDict = NULL;
+  PyObject *pFunc = NULL;
+  PyObject *pArgs = NULL;
+  PyObject *pResVal = NULL;
+
+  PyRun_SimpleString("import sys");
+  PyRun_SimpleString(sysPath); 
+
+  pModule = PyImport_ImportModule("Relay");
+  if (!pModule) {
+    log_info(LD_DIR, "Fatal Python error: Load python file failed.");
+    return 0;
+  }
+  pDict = PyModule_GetDict(pModule);
+  if (!pDict) {
+    log_info(LD_DIR, "Fatal Python error: Can't find dict in python file.");
+    return 0;
+  }
+
+  // ====== BGW Broadcast Encryption Scheme ======
+  int Counter = 0;
+  PyObject *pRes2 = NULL;
+  pFunc = PyDict_GetItemString(pDict, "relayGetSet");
+  pResVal = PyObject_CallObject(pFunc, pArgs);
+  PyArg_ParseTuple(pResVal, "i|O", &Counter, &pRes2);
+
+  log_info(LD_DIR, "The number of CurrentCounter is %d.", Counter);
+  if (!PyList_Check(pRes2)){
+      log_info(LD_DIR, "Failed to fetch the set S used for broadcast encryption.");
+  }
+
+  int SizeOfList = PyList_Size(pRes2);
+  log_info(LD_DIR, "SizeOfList: %d", SizeOfList);
+  int relaySet[SizeOfList];
+  for(int i=0; i<SizeOfList; i++) {
+    PyObject *listItem = PyList_GetItem(pRes2, i);
+    int relayIndex = 0;
+    PyArg_Parse(listItem, "i", &relayIndex);
+    relaySet[i] = relayIndex;
+    Py_DECREF(listItem);
+  }
+
+  int fileEnd = 0;
+  for(int i=0; i<SizeOfList; i++) {
+    if (i == SizeOfList-1) {
+        fileEnd = 1;
+    }
+    int relayID = relaySet[i];
+    pFunc = PyDict_GetItemString(pDict, "relayDownloadSRI");
+    pArgs = PyTuple_New(1);
+    PyTuple_SetItem(pArgs, 0, Py_BuildValue("i", relayID));
+    pResVal = PyObject_CallObject(pFunc, pArgs);
+
+    PyObject *pHdr = NULL;
+    PyObject *pRelaySet = NULL;
+    char *enSRI = NULL;
+    PyArg_ParseTuple(pResVal, "O|O|s", &pRelaySet, &pHdr, &enSRI);
+
+    if(strlen(enSRI) != 0) {
+      int setNum = PyList_Size(pRelaySet);
+      int S[setNum];
+      for(int j=0; j<setNum; j++) {
+        PyObject *listItem = PyList_GetItem(pRelaySet, j);
+        int arrItem = 0;
+        PyArg_Parse(listItem, "i", &arrItem);
+        S[j] = arrItem;
+        Py_DECREF(listItem);
+      }
+
+      int HdrNum = PyList_Size(pHdr);
+      char *Hdr[HdrNum];
+      for(int j=0; j<HdrNum; j++) {
+        PyObject *listItem = PyObject_Str(PyList_GetItem(pHdr, j));
+        char* resultStr = "";
+        PyArg_Parse(listItem, "s", &resultStr);
+        Hdr[j] = (char*)malloc(200*sizeof(char));
+        strcpy(Hdr[j], resultStr);
+        Py_DECREF(listItem);
+      }
+
+      char *decKey = NULL;
+      bkem_decryption(&decKey, S, setNum, (int) myIndex, Hdr);
+
+      pFunc = PyDict_GetItemString(pDict, "relayDecryptSRIs");
+      pArgs = PyTuple_New(4);
+      PyTuple_SetItem(pArgs, 0, Py_BuildValue("i", relayID));
+      PyTuple_SetItem(pArgs, 1, Py_BuildValue("s", enSRI));
+      PyTuple_SetItem(pArgs, 2, Py_BuildValue("s", decKey));
+      PyTuple_SetItem(pArgs, 3, Py_BuildValue("i", fileEnd));
+      pResVal = PyObject_CallObject(pFunc, pArgs);
+    }
+  }
+
+  log_info(LD_DIR, "Successfully downloads NIME from blockchain.");
+  Py_XDECREF(pModule);  
+  Py_XDECREF(pArgs);
+  Py_XDECREF(pResVal);
+  //Py_Finalize();
+  return 1;
+}
+
 /** If <b>force</b> is true, or our descriptor is out-of-date, rebuild a fresh
  * routerinfo, signed server descriptor, and extra-info document for this OR.
  *
  * Return true on success, else false on temporary error.
  */
 bool
-router_rebuild_descriptor(int force)
+router_rebuild_descriptor(int force, int flag)
 {
   int err = 0;
   routerinfo_t *ri;
@@ -2464,6 +3017,29 @@
     return false;
   }
 
+  // ************
+  // BADNET
+  // ************
+  if (flag == 1) {
+    if (relay_is_registered == false) {
+      if (relay_register() == 0) {
+        log_info(LD_DIR, "Relay registration failure.");
+        return false;
+      }
+    }
+
+    if (router_download_descriptor_from_blockchain() == 0) {
+      log_info(LD_DIR, "Relay download failure.");
+      return false;
+    }
+
+    if (router_upload_descriptor_to_blockchain(ri) == 0) {
+      log_info(LD_DIR, "Relay upload failure.");
+      return false;
+    }
+    
+  }
+
   routerinfo_free(desc_routerinfo);
   desc_routerinfo = ri;
   extrainfo_free(desc_extrainfo);
@@ -2472,9 +3048,16 @@
   desc_clean_since = time(NULL);
   desc_needs_upload = 1;
   desc_gen_reason = desc_dirty_reason;
+
+  // ************
+  // BADNET
+  // ************
+  /*
   if (BUG(desc_gen_reason == NULL)) {
     desc_gen_reason = "descriptor was marked dirty earlier, for no reason.";
   }
+  */
+
   desc_dirty_reason = NULL;
   control_event_my_descriptor_changed();
   return true;
diff -urN tor-0.4.6.5/src/feature/relay/router.h BADNET/src/feature/relay/router.h
--- tor-0.4.6.5/src/feature/relay/router.h	2021-04-16 00:41:14
+++ BADNET/src/feature/relay/router.h	2022-11-18 19:46:39
@@ -14,6 +14,11 @@
 
 #include "lib/testsupport/testsupport.h"
 
+// ************
+// BADNET
+// ************
+#include "feature/relay/bkem.h"
+
 struct curve25519_keypair_t;
 struct ed25519_keypair_t;
 
@@ -102,7 +107,13 @@
 int router_is_me(const routerinfo_t *router);
 bool router_addr_is_my_published_addr(const tor_addr_t *addr);
 int router_build_fresh_descriptor(routerinfo_t **r, extrainfo_t **e);
-bool router_rebuild_descriptor(int force);
+
+// ************
+// BADNET
+// ************
+// bool router_rebuild_descriptor(int force);
+bool router_rebuild_descriptor(int force, int flag);
+
 char *router_dump_router_to_string(routerinfo_t *router,
                              const crypto_pk_t *ident_key,
                              const crypto_pk_t *tap_key,
